From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Kevin Raneri <kevin.raneri@gmail.com>
Date: Tue, 9 Nov 2021 23:36:56 -0500
Subject: [PATCH] Pufferfish Server Patches


diff --git a/build.gradle.kts b/build.gradle.kts
index 648281575eb8d45a5c06549eb3d0f517c086fe64..6fc937c1aac700c00e76e4d9817fbd5cf2575a23 100644
--- a/build.gradle.kts
+++ b/build.gradle.kts
@@ -47,6 +47,14 @@ dependencies {
     runtimeOnly("org.apache.maven.resolver:maven-resolver-connector-basic:1.9.18")
     runtimeOnly("org.apache.maven.resolver:maven-resolver-transport-http:1.9.18")
 
+    // Pufferfish start
+    implementation("me.carleslc.Simple-YAML:Simple-Yaml:1.8.4") {
+        // exclude to prioritize version in api
+        exclude(group="org.yaml", module="snakeyaml")
+    }
+    // Pufferfish end
+    implementation("com.github.technove:Flare:34637f3f87") // Pufferfish - flare
+
     testImplementation("io.github.classgraph:classgraph:4.8.47") // Paper - mob goal test
     testImplementation("org.junit.jupiter:junit-jupiter:5.10.2")
     testImplementation("org.hamcrest:hamcrest:2.2")
@@ -71,6 +79,14 @@ paperweight {
     craftBukkitPackageVersion.set("v1_21_R1") // also needs to be updated in MappingEnvironment
 }
 
+
+// Pufferfish Start
+tasks.withType<JavaCompile> {
+    val compilerArgs = options.compilerArgs
+    compilerArgs.add("--add-modules=jdk.incubator.vector")
+}
+// Pufferfish End
+
 tasks.jar {
     archiveClassifier.set("dev")
 
diff --git a/src/main/java/ca/spottedleaf/moonrise/common/util/CoordinateUtils.java b/src/main/java/ca/spottedleaf/moonrise/common/util/CoordinateUtils.java
index 31b92bd48828cbea25b44a9f0f96886347aa1ae6..5f4238c6cf4bc78542826f3fd4d2cbc4861d72c8 100644
--- a/src/main/java/ca/spottedleaf/moonrise/common/util/CoordinateUtils.java
+++ b/src/main/java/ca/spottedleaf/moonrise/common/util/CoordinateUtils.java
@@ -16,7 +16,7 @@ public final class CoordinateUtils {
     }
 
     public static long getChunkKey(final Entity entity) {
-        return ((Mth.lfloor(entity.getZ()) >> 4) << 32) | ((Mth.lfloor(entity.getX()) >> 4) & 0xFFFFFFFFL);
+        return ((long)(entity.blockPosition.getZ() >> 4) << 32) | ((long)(entity.blockPosition.getX() >> 4) & 0xFFFFFFFFL); // Pufferfish - eliminate double->long cast in hotpath
     }
 
     public static long getChunkKey(final ChunkPos pos) {
diff --git a/src/main/java/co/aikar/timings/TimingsExport.java b/src/main/java/co/aikar/timings/TimingsExport.java
index 7620c72a4c243cbeea245203ce03a97cbfa7d922..b35a9f4c5f8960864c402ede8a51fb5ab9c4fcc0 100644
--- a/src/main/java/co/aikar/timings/TimingsExport.java
+++ b/src/main/java/co/aikar/timings/TimingsExport.java
@@ -240,7 +240,8 @@ public class TimingsExport extends Thread {
         parent.put("config", createObject(
             pair("spigot", mapAsJSON(Bukkit.spigot().getSpigotConfig(), null)),
             pair("bukkit", mapAsJSON(Bukkit.spigot().getBukkitConfig(), null)),
-            pair("paper", mapAsJSON(Bukkit.spigot().getPaperConfig(), null))
+            pair("paper", mapAsJSON(Bukkit.spigot().getPaperConfig(), null)), // Pufferfish
+            pair("pufferfish", mapAsJSON(gg.pufferfish.pufferfish.PufferfishConfig.getConfigCopy(), null)) // Pufferfish
         ));
 
         new TimingsExport(listeners, parent, history).start();
diff --git a/src/main/java/gg/airplane/structs/FluidDirectionCache.java b/src/main/java/gg/airplane/structs/FluidDirectionCache.java
new file mode 100644
index 0000000000000000000000000000000000000000..aa8467b9dda1f7707e41f50ac7b3e9d7343723ec
--- /dev/null
+++ b/src/main/java/gg/airplane/structs/FluidDirectionCache.java
@@ -0,0 +1,136 @@
+package gg.airplane.structs;
+
+import it.unimi.dsi.fastutil.HashCommon;
+
+/**
+ * This is a replacement for the cache used in FluidTypeFlowing.
+ * The requirements for the previous cache were:
+ *  - Store 200 entries
+ *  - Look for the flag in the cache
+ *  - If it exists, move to front of cache
+ *  - If it doesn't exist, remove last entry in cache and insert in front
+ *
+ * This class accomplishes something similar, however has a few different
+ * requirements put into place to make this more optimize:
+ *
+ *  - maxDistance is the most amount of entries to be checked, instead
+ *    of having to check the entire list.
+ *  - In combination with that, entries are all tracked by age and how
+ *    frequently they're used. This enables us to remove old entries,
+ *    without constantly shifting any around.
+ *
+ * Usage of the previous map would have to reset the head every single usage,
+ * shifting the entire map. Here, nothing happens except an increment when
+ * the cache is hit, and when it needs to replace an old element only a single
+ * element is modified.
+ */
+public class FluidDirectionCache<T> {
+
+    private static class FluidDirectionEntry<T> {
+        private final T data;
+        private final boolean flag;
+        private int uses = 0;
+        private int age = 0;
+
+        private FluidDirectionEntry(T data, boolean flag) {
+            this.data = data;
+            this.flag = flag;
+        }
+
+        public int getValue() {
+            return this.uses - (this.age >> 1); // age isn't as important as uses
+        }
+
+        public void incrementUses() {
+            this.uses = this.uses + 1 & Integer.MAX_VALUE;
+        }
+
+        public void incrementAge() {
+            this.age = this.age + 1 & Integer.MAX_VALUE;
+        }
+    }
+
+    private final FluidDirectionEntry[] entries;
+    private final int mask;
+    private final int maxDistance; // the most amount of entries to check for a value
+
+    public FluidDirectionCache(int size) {
+        int arraySize = HashCommon.nextPowerOfTwo(size);
+        this.entries = new FluidDirectionEntry[arraySize];
+        this.mask = arraySize - 1;
+        this.maxDistance = Math.min(arraySize, 4);
+    }
+
+    public Boolean getValue(T data) {
+        FluidDirectionEntry curr;
+        int pos;
+
+        if ((curr = this.entries[pos = HashCommon.mix(data.hashCode()) & this.mask]) == null) {
+            return null;
+        } else if (data.equals(curr.data)) {
+            curr.incrementUses();
+            return curr.flag;
+        }
+
+        int checked = 1; // start at 1 because we already checked the first spot above
+
+        while ((curr = this.entries[pos = (pos + 1) & this.mask]) != null) {
+            if (data.equals(curr.data)) {
+                curr.incrementUses();
+                return curr.flag;
+            } else if (++checked >= this.maxDistance) {
+                break;
+            }
+        }
+
+        return null;
+    }
+
+    public void putValue(T data, boolean flag) {
+        FluidDirectionEntry<T> curr;
+        int pos;
+
+        if ((curr = this.entries[pos = HashCommon.mix(data.hashCode()) & this.mask]) == null) {
+            this.entries[pos] = new FluidDirectionEntry<>(data, flag); // add
+            return;
+        } else if (data.equals(curr.data)) {
+            curr.incrementUses();
+            return;
+        }
+
+        int checked = 1; // start at 1 because we already checked the first spot above
+
+        while ((curr = this.entries[pos = (pos + 1) & this.mask]) != null) {
+            if (data.equals(curr.data)) {
+                curr.incrementUses();
+                return;
+            } else if (++checked >= this.maxDistance) {
+                this.forceAdd(data, flag);
+                return;
+            }
+        }
+
+        this.entries[pos] = new FluidDirectionEntry<>(data, flag); // add
+    }
+
+    private void forceAdd(T data, boolean flag) {
+        int expectedPos = HashCommon.mix(data.hashCode()) & this.mask;
+
+        int toRemovePos = expectedPos;
+        FluidDirectionEntry entryToRemove = this.entries[toRemovePos];
+
+        for (int i = expectedPos + 1; i < expectedPos + this.maxDistance; i++) {
+            int pos = i & this.mask;
+            FluidDirectionEntry entry = this.entries[pos];
+            if (entry.getValue() < entryToRemove.getValue()) {
+                toRemovePos = pos;
+                entryToRemove = entry;
+            }
+
+            entry.incrementAge(); // use this as a mechanism to age the other entries
+        }
+
+        // remove the least used/oldest entry
+        this.entries[toRemovePos] = new FluidDirectionEntry(data, flag);
+    }
+}
diff --git a/src/main/java/gg/airplane/structs/ItemListWithBitset.java b/src/main/java/gg/airplane/structs/ItemListWithBitset.java
new file mode 100644
index 0000000000000000000000000000000000000000..1b7a4ee47f4445d7f2ac91d3a73ae113edbdddb2
--- /dev/null
+++ b/src/main/java/gg/airplane/structs/ItemListWithBitset.java
@@ -0,0 +1,114 @@
+package gg.airplane.structs;
+
+import net.minecraft.core.NonNullList;
+import net.minecraft.world.item.ItemStack;
+import org.apache.commons.lang.Validate;
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
+
+import java.util.AbstractList;
+import java.util.Arrays;
+import java.util.List;
+
+public class ItemListWithBitset extends AbstractList<ItemStack> {
+    public static ItemListWithBitset fromList(List<ItemStack> list) {
+        if (list instanceof ItemListWithBitset ours) {
+            return ours;
+        }
+        return new ItemListWithBitset(list);
+    }
+
+    private static ItemStack[] createArray(int size) {
+        ItemStack[] array = new ItemStack[size];
+        Arrays.fill(array, ItemStack.EMPTY);
+        return array;
+    }
+
+    private final ItemStack[] items;
+
+    private long bitSet = 0;
+    private final long allBits;
+
+    private static class OurNonNullList extends NonNullList<ItemStack> {
+        protected OurNonNullList(List<ItemStack> delegate) {
+            super(delegate, ItemStack.EMPTY);
+        }
+    }
+
+    public final NonNullList<ItemStack> nonNullList = new OurNonNullList(this);
+
+    private ItemListWithBitset(List<ItemStack> list) {
+        this(list.size());
+
+        for (int i = 0; i < list.size(); i++) {
+            this.set(i, list.get(i));
+        }
+    }
+
+    public ItemListWithBitset(int size) {
+        Validate.isTrue(size < Long.BYTES * 8, "size is too large");
+
+        this.items = createArray(size);
+        this.allBits = ((1L << size) - 1);
+    }
+
+    public boolean isCompletelyEmpty() {
+        return this.bitSet == 0;
+    }
+
+    public boolean hasFullStacks() {
+        return (this.bitSet & this.allBits) == allBits;
+    }
+
+    @Override
+    public ItemStack set(int index, @NotNull ItemStack itemStack) {
+        ItemStack existing = this.items[index];
+
+        this.items[index] = itemStack;
+
+        if (itemStack == ItemStack.EMPTY) {
+            this.bitSet &= ~(1L << index);
+        } else {
+            this.bitSet |= 1L << index;
+        }
+
+        return existing;
+    }
+
+    @NotNull
+    @Override
+    public ItemStack get(int var0) {
+        return this.items[var0];
+    }
+
+    @Override
+    public int size() {
+        return this.items.length;
+    }
+
+    @Override
+    public void clear() {
+        Arrays.fill(this.items, ItemStack.EMPTY);
+    }
+
+    // these are unsupported for block inventories which have a static size
+    @Override
+    public void add(int var0, ItemStack var1) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public ItemStack remove(int var0) {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public String toString() {
+        return "ItemListWithBitset{" +
+          "items=" + Arrays.toString(items) +
+          ", bitSet=" + Long.toString(bitSet, 2) +
+          ", allBits=" + Long.toString(allBits, 2) +
+          ", size=" + this.items.length +
+          '}';
+    }
+}
diff --git a/src/main/java/gg/airplane/structs/Long2FloatAgingCache.java b/src/main/java/gg/airplane/structs/Long2FloatAgingCache.java
new file mode 100644
index 0000000000000000000000000000000000000000..a7f297ebb569f7c1f205e967ca485be70013a714
--- /dev/null
+++ b/src/main/java/gg/airplane/structs/Long2FloatAgingCache.java
@@ -0,0 +1,119 @@
+package gg.airplane.structs;
+
+import it.unimi.dsi.fastutil.HashCommon;
+
+/**
+ * A replacement for the cache used in Biome.
+ */
+public class Long2FloatAgingCache {
+
+    private static class AgingEntry {
+        private long data;
+        private float value;
+        private int uses = 0;
+        private int age = 0;
+
+        private AgingEntry(long data, float value) {
+            this.data = data;
+            this.value = value;
+        }
+
+        public void replace(long data, float flag) {
+            this.data = data;
+            this.value = flag;
+        }
+
+        public int getValue() {
+            return this.uses - (this.age >> 1); // age isn't as important as uses
+        }
+
+        public void incrementUses() {
+            this.uses = this.uses + 1 & Integer.MAX_VALUE;
+        }
+
+        public void incrementAge() {
+            this.age = this.age + 1 & Integer.MAX_VALUE;
+        }
+    }
+
+    private final AgingEntry[] entries;
+    private final int mask;
+    private final int maxDistance; // the most amount of entries to check for a value
+
+    public Long2FloatAgingCache(int size) {
+        int arraySize = HashCommon.nextPowerOfTwo(size);
+        this.entries = new AgingEntry[arraySize];
+        this.mask = arraySize - 1;
+        this.maxDistance = Math.min(arraySize, 4);
+    }
+
+    public float getValue(long data) {
+        AgingEntry curr;
+        int pos;
+
+        if ((curr = this.entries[pos = HashCommon.mix(HashCommon.long2int(data)) & this.mask]) == null) {
+            return Float.NaN;
+        } else if (data == curr.data) {
+            curr.incrementUses();
+            return curr.value;
+        }
+
+        int checked = 1; // start at 1 because we already checked the first spot above
+
+        while ((curr = this.entries[pos = (pos + 1) & this.mask]) != null) {
+            if (data == curr.data) {
+                curr.incrementUses();
+                return curr.value;
+            } else if (++checked >= this.maxDistance) {
+                break;
+            }
+        }
+
+        return Float.NaN;
+    }
+
+    public void putValue(long data, float value) {
+        AgingEntry curr;
+        int pos;
+
+        if ((curr = this.entries[pos = HashCommon.mix(HashCommon.long2int(data)) & this.mask]) == null) {
+            this.entries[pos] = new AgingEntry(data, value); // add
+            return;
+        } else if (data == curr.data) {
+            curr.incrementUses();
+            return;
+        }
+
+        int checked = 1; // start at 1 because we already checked the first spot above
+
+        while ((curr = this.entries[pos = (pos + 1) & this.mask]) != null) {
+            if (data == curr.data) {
+                curr.incrementUses();
+                return;
+            } else if (++checked >= this.maxDistance) {
+                this.forceAdd(data, value);
+                return;
+            }
+        }
+
+        this.entries[pos] = new AgingEntry(data, value); // add
+    }
+
+    private void forceAdd(long data, float value) {
+        int expectedPos = HashCommon.mix(HashCommon.long2int(data)) & this.mask;
+        AgingEntry entryToRemove = this.entries[expectedPos];
+
+        for (int i = expectedPos + 1; i < expectedPos + this.maxDistance; i++) {
+            int pos = i & this.mask;
+            AgingEntry entry = this.entries[pos];
+            if (entry.getValue() < entryToRemove.getValue()) {
+                entryToRemove = entry;
+            }
+
+            entry.incrementAge(); // use this as a mechanism to age the other entries
+        }
+
+        // remove the least used/oldest entry
+        entryToRemove.replace(data, value);
+    }
+}
diff --git a/src/main/java/gg/airplane/structs/ThreadUnsafeRandom.java b/src/main/java/gg/airplane/structs/ThreadUnsafeRandom.java
new file mode 100644
index 0000000000000000000000000000000000000000..5de68a00bb72e99cba60e0ab0967c1a9969f8762
--- /dev/null
+++ b/src/main/java/gg/airplane/structs/ThreadUnsafeRandom.java
@@ -0,0 +1,66 @@
+package gg.airplane.structs;
+
+import net.minecraft.util.RandomSource;
+import net.minecraft.world.level.levelgen.LegacyRandomSource;
+import net.minecraft.world.level.levelgen.PositionalRandomFactory;
+import org.checkerframework.checker.nullness.qual.NonNull;
+import org.checkerframework.framework.qual.DefaultQualifier;
+
+// https://github.com/PaperMC/Paper/blob/20f51650a9648c78e608d4d80f0e89dba24ac799/patches/server/1004-Optimise-random-block-ticking.patch#L21-L91
+@DefaultQualifier(NonNull.class)
+public final class ThreadUnsafeRandom extends LegacyRandomSource {
+
+    // See javadoc and internal comments for java.util.Random where these values come from, how they are used, and the author for them.
+    private static final long multiplier = 0x5DEECE66DL;
+    private static final long addend = 0xBL;
+    private static final long mask = (1L << 48) - 1;
+
+    private static long initialScramble(long seed) {
+        return (seed ^ multiplier) & mask;
+    }
+
+    private long seed;
+
+    public ThreadUnsafeRandom(long seed) {
+        super(seed);
+    }
+
+    @Override
+    public RandomSource fork() {
+        return new ThreadUnsafeRandom(this.nextLong());
+    }
+
+    @Override
+    public PositionalRandomFactory forkPositional() {
+        throw new UnsupportedOperationException();
+    }
+
+    @Override
+    public void setSeed(long seed) {
+        // note: called by Random constructor
+        this.seed = initialScramble(seed);
+    }
+
+    @Override
+    public int next(int bits) {
+        // avoid the expensive CAS logic used by superclass
+        return (int) (((this.seed = this.seed * multiplier + addend) & mask) >>> (48 - bits));
+    }
+
+    // Taken from
+    // https://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction/
+    // https://github.com/lemire/Code-used-on-Daniel-Lemire-s-blog/blob/master/2016/06/25/fastrange.c
+    // Original license is public domain
+    public static int fastRandomBounded(final long randomInteger, final long limit) {
+        // randomInteger must be [0, pow(2, 32))
+        // limit must be [0, pow(2, 32))
+        return (int)((randomInteger * limit) >>> 32);
+    }
+
+    @Override
+    public int nextInt(int bound) {
+        // yes this breaks random's spec
+        // however there's nothing that uses this class that relies on it
+        return fastRandomBounded(this.next(32) & 0xFFFFFFFFL, bound);
+    }
+}
diff --git a/src/main/java/gg/pufferfish/pufferfish/PufferfishCommand.java b/src/main/java/gg/pufferfish/pufferfish/PufferfishCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..020368da69b9a492155f6de6297f74732f4ab6ea
--- /dev/null
+++ b/src/main/java/gg/pufferfish/pufferfish/PufferfishCommand.java
@@ -0,0 +1,68 @@
+package gg.pufferfish.pufferfish;
+
+import java.io.IOException;
+import java.util.Collections;
+import java.util.List;
+import java.util.stream.Collectors;
+import java.util.stream.Stream;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.format.NamedTextColor;
+import net.md_5.bungee.api.ChatColor;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.Bukkit;
+import org.bukkit.Location;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+
+public class PufferfishCommand extends Command {
+
+    public PufferfishCommand() {
+        super("pufferfish");
+        this.description = "Pufferfish related commands";
+        this.usageMessage = "/pufferfish [reload | version]";
+        this.setPermission("bukkit.command.pufferfish");
+    }
+    
+    public static void init() {
+        MinecraftServer.getServer().server.getCommandMap().register("pufferfish", "Pufferfish", new PufferfishCommand());
+    }
+
+    @Override
+    public List<String> tabComplete(CommandSender sender, String alias, String[] args, Location location) throws IllegalArgumentException {
+        if (args.length == 1) {
+            return Stream.of("reload", "version")
+              .filter(arg -> arg.startsWith(args[0].toLowerCase()))
+              .collect(Collectors.toList());
+        }
+        return Collections.emptyList();
+    }
+
+    @Override
+    public boolean execute(CommandSender sender, String commandLabel, String[] args) {
+        if (!testPermission(sender)) return true;
+        String prefix = ChatColor.of("#12fff6") + "" + ChatColor.BOLD + "Pufferfish » " + ChatColor.of("#e8f9f9");
+
+        if (args.length != 1) {
+            sender.sendMessage(prefix + "Usage: " + usageMessage);
+            args = new String[]{"version"};
+        }
+
+        if (args[0].equalsIgnoreCase("reload")) {
+            MinecraftServer console = MinecraftServer.getServer();
+            try {
+                PufferfishConfig.load();
+            } catch (IOException e) {
+                sender.sendMessage(Component.text("Failed to reload.", NamedTextColor.RED));
+                e.printStackTrace();
+                return true;
+            }
+            console.server.reloadCount++;
+
+            Command.broadcastCommandMessage(sender, prefix + "Pufferfish configuration has been reloaded.");
+        } else if (args[0].equalsIgnoreCase("version")) {
+            Command.broadcastCommandMessage(sender, prefix + "This server is running " + Bukkit.getName() + " version " + Bukkit.getVersion() + " (Implementing API version " + Bukkit.getBukkitVersion() + ")");
+        }
+
+        return true;
+    }
+}
diff --git a/src/main/java/gg/pufferfish/pufferfish/PufferfishConfig.java b/src/main/java/gg/pufferfish/pufferfish/PufferfishConfig.java
new file mode 100644
index 0000000000000000000000000000000000000000..14ee6db077d419399f0f8246c8cd5a690cb018c2
--- /dev/null
+++ b/src/main/java/gg/pufferfish/pufferfish/PufferfishConfig.java
@@ -0,0 +1,311 @@
+package gg.pufferfish.pufferfish;
+
+import gg.pufferfish.pufferfish.flare.FlareCommand;
+import gg.pufferfish.pufferfish.simd.SIMDDetection;
+import net.minecraft.core.registries.BuiltInRegistries;
+import net.minecraft.server.MinecraftServer;
+import net.minecraft.world.entity.EntityType;
+import org.bukkit.command.SimpleCommandMap;
+import org.bukkit.configuration.ConfigurationSection;
+import org.bukkit.configuration.MemoryConfiguration;
+import org.jetbrains.annotations.Nullable;
+import org.simpleyaml.configuration.comments.CommentType;
+import org.simpleyaml.configuration.file.YamlFile;
+import org.simpleyaml.exceptions.InvalidConfigurationException;
+
+import java.io.File;
+import java.io.IOException;
+import java.lang.reflect.Method;
+import java.lang.reflect.Modifier;
+import java.net.URI;
+import java.util.Collections;
+import java.util.List;
+import java.util.Locale;
+import java.util.Map;
+
+public class PufferfishConfig {
+
+	private static final YamlFile config = new YamlFile();
+	private static int updates = 0;
+
+	private static ConfigurationSection convertToBukkit(org.simpleyaml.configuration.ConfigurationSection section) {
+		ConfigurationSection newSection = new MemoryConfiguration();
+		for (String key : section.getKeys(false)) {
+			if (section.isConfigurationSection(key)) {
+				newSection.set(key, convertToBukkit(section.getConfigurationSection(key)));
+			} else {
+				newSection.set(key, section.get(key));
+			}
+		}
+		return newSection;
+	}
+
+	public static ConfigurationSection getConfigCopy() {
+		return convertToBukkit(config);
+	}
+
+	public static int getUpdates() {
+		return updates;
+	}
+
+	public static void load() throws IOException {
+		File configFile = new File("pufferfish.yml");
+
+		if (configFile.exists()) {
+			try {
+				config.load(configFile);
+			} catch (InvalidConfigurationException e) {
+				throw new IOException(e);
+			}
+		}
+
+		getString("info.version", "1.0");
+		setComment("info",
+				"Pufferfish Configuration",
+				"Check out Pufferfish Host for maximum performance server hosting: https://pufferfish.host",
+				"Join our Discord for support: https://discord.gg/reZw4vQV9H",
+				"Download new builds at https://ci.pufferfish.host/job/Pufferfish");
+
+		for (Method method : PufferfishConfig.class.getDeclaredMethods()) {
+			if (Modifier.isStatic(method.getModifiers()) && Modifier.isPrivate(method.getModifiers()) && method.getParameterCount() == 0 &&
+					method.getReturnType() == Void.TYPE && !method.getName().startsWith("lambda")) {
+				method.setAccessible(true);
+				try {
+					method.invoke(null);
+				} catch (Throwable t) {
+					MinecraftServer.LOGGER.warn("Failed to load configuration option from " + method.getName(), t);
+				}
+			}
+		}
+
+		updates++;
+
+		config.save(configFile);
+
+		// Attempt to detect vectorization
+		try {
+			SIMDDetection.isEnabled = SIMDDetection.canEnable(PufferfishLogger.LOGGER);
+			SIMDDetection.versionLimited = SIMDDetection.getJavaVersion() != 17 && SIMDDetection.getJavaVersion() != 21;
+		} catch (NoClassDefFoundError | Exception ignored) {}
+
+		if (false) // don't care if activated or not
+		if (SIMDDetection.isEnabled) {
+			PufferfishLogger.LOGGER.info("SIMD operations detected as functional. Will replace some operations with faster versions.");
+		} else if (SIMDDetection.versionLimited) {
+			PufferfishLogger.LOGGER.warning("Will not enable SIMD! These optimizations are only safely supported on Java 17 and Java 21.");
+		} else {
+			PufferfishLogger.LOGGER.warning("SIMD operations are available for your server, but are not configured!");
+			PufferfishLogger.LOGGER.warning("To enable additional optimizations, add \"--add-modules=jdk.incubator.vector\" to your startup flags, BEFORE the \"-jar\".");
+			PufferfishLogger.LOGGER.warning("If you have already added this flag, then SIMD operations are not supported on your JVM or CPU.");
+			PufferfishLogger.LOGGER.warning("Debug: Java: " + System.getProperty("java.version") + ", test run: " + SIMDDetection.testRun);
+		}
+	}
+
+	private static void setComment(String key, String... comment) {
+		if (config.contains(key)) {
+			config.setComment(key, String.join("\n", comment), CommentType.BLOCK);
+		}
+	}
+
+	private static void ensureDefault(String key, Object defaultValue, String... comment) {
+		if (!config.contains(key)) {
+			config.set(key, defaultValue);
+			config.setComment(key, String.join("\n", comment), CommentType.BLOCK);
+		}
+	}
+
+	private static boolean getBoolean(String key, boolean defaultValue, String... comment) {
+		return getBoolean(key, null, defaultValue, comment);
+	}
+
+	private static boolean getBoolean(String key, @Nullable String oldKey, boolean defaultValue, String... comment) {
+		ensureDefault(key, defaultValue, comment);
+		return config.getBoolean(key, defaultValue);
+	}
+
+	private static int getInt(String key, int defaultValue, String... comment) {
+		return getInt(key, null, defaultValue, comment);
+	}
+
+	private static int getInt(String key, @Nullable String oldKey, int defaultValue, String... comment) {
+		ensureDefault(key, defaultValue, comment);
+		return config.getInt(key, defaultValue);
+	}
+
+	private static double getDouble(String key, double defaultValue, String... comment) {
+		return getDouble(key, null, defaultValue, comment);
+	}
+
+	private static double getDouble(String key, @Nullable String oldKey, double defaultValue, String... comment) {
+		ensureDefault(key, defaultValue, comment);
+		return config.getDouble(key, defaultValue);
+	}
+
+	private static String getString(String key, String defaultValue, String... comment) {
+		return getOldString(key, null, defaultValue, comment);
+	}
+
+	private static String getOldString(String key, @Nullable String oldKey, String defaultValue, String... comment) {
+		ensureDefault(key, defaultValue, comment);
+		return config.getString(key, defaultValue);
+	}
+
+	private static List<String> getStringList(String key, List<String> defaultValue, String... comment) {
+		return getStringList(key, null, defaultValue, comment);
+	}
+
+	private static List<String> getStringList(String key, @Nullable String oldKey, List<String> defaultValue, String... comment) {
+		ensureDefault(key, defaultValue, comment);
+		return config.getStringList(key);
+	}
+
+	public static String sentryDsn;
+	private static void sentry() {
+		String sentryEnvironment = System.getenv("SENTRY_DSN");
+		String sentryConfig = getString("sentry-dsn", "", "Sentry DSN for improved error logging, leave blank to disable", "Obtain from https://sentry.io/");
+
+		sentryDsn = sentryEnvironment == null ? sentryConfig : sentryEnvironment;
+		if (sentryDsn != null && !sentryDsn.isBlank()) {
+			gg.pufferfish.pufferfish.sentry.SentryManager.init();
+		}
+	}
+
+	public static boolean enableBooks;
+	private static void books() {
+		enableBooks = getBoolean("enable-books", true,
+				"Whether or not books should be writeable.",
+				"Servers that anticipate being a target for duping may want to consider",
+				"disabling this option.",
+				"This can be overridden per-player with the permission pufferfish.usebooks");
+	}
+
+	public static boolean enableSuffocationOptimization;
+	private static void suffocationOptimization() {
+		enableSuffocationOptimization = getBoolean("enable-suffocation-optimization", true,
+				"Optimizes the suffocation check by selectively skipping",
+				"the check in a way that still appears vanilla. This should",
+				"be left enabled on most servers, but is provided as a",
+				"configuration option if the vanilla deviation is undesirable.");
+	}
+
+	public static boolean enableAsyncMobSpawning;
+	public static boolean asyncMobSpawningInitialized;
+	private static void asyncMobSpawning() {
+		boolean temp = getBoolean("enable-async-mob-spawning", true,
+				"Whether or not asynchronous mob spawning should be enabled.",
+				"On servers with many entities, this can improve performance by up to 15%. You must have",
+				"paper's per-player-mob-spawns setting set to true for this to work.",
+				"One quick note - this does not actually spawn mobs async (that would be very unsafe).",
+				"This just offloads some expensive calculations that are required for mob spawning.");
+
+		// This prevents us from changing the value during a reload.
+		if (!asyncMobSpawningInitialized) {
+			asyncMobSpawningInitialized = true;
+			enableAsyncMobSpawning = temp;
+		}
+	}
+
+    public static int maxProjectileLoadsPerTick;
+    public static int maxProjectileLoadsPerProjectile;
+    private static void projectileLoading() {
+        maxProjectileLoadsPerTick = getInt("projectile.max-loads-per-tick", 10, "Controls how many chunks are allowed", "to be sync loaded by projectiles in a tick.");
+        maxProjectileLoadsPerProjectile = getInt("projectile.max-loads-per-projectile", 10, "Controls how many chunks a projectile", "can load in its lifetime before it gets", "automatically removed.");
+
+        setComment("projectile", "Optimizes projectile settings");
+    }
+
+
+    public static boolean dearEnabled;
+    public static int startDistance;
+    public static int startDistanceSquared;
+    public static int maximumActivationPrio;
+    public static int activationDistanceMod;
+
+    private static void dynamicActivationOfBrains() throws IOException {
+        dearEnabled = getBoolean("dab.enabled", "activation-range.enabled", true);
+        startDistance = getInt("dab.start-distance", "activation-range.start-distance", 12,
+                "This value determines how far away an entity has to be",
+                "from the player to start being effected by DEAR.");
+        startDistanceSquared = startDistance * startDistance;
+        maximumActivationPrio = getInt("dab.max-tick-freq", "activation-range.max-tick-freq", 20,
+                "This value defines how often in ticks, the furthest entity",
+                "will get their pathfinders and behaviors ticked. 20 = 1s");
+        activationDistanceMod = getInt("dab.activation-dist-mod", "activation-range.activation-dist-mod", 8,
+                "This value defines how much distance modifies an entity's",
+                "tick frequency. freq = (distanceToPlayer^2) / (2^value)",
+                "If you want further away entities to tick less often, use 7.",
+                "If you want further away entities to tick more often, try 9.");
+
+        for (EntityType<?> entityType : BuiltInRegistries.ENTITY_TYPE) {
+            entityType.dabEnabled = true; // reset all, before setting the ones to true
+        }
+        getStringList("dab.blacklisted-entities", "activation-range.blacklisted-entities", Collections.emptyList(), "A list of entities to ignore for activation")
+                .forEach(name -> EntityType.byString(name).ifPresentOrElse(entityType -> {
+                    entityType.dabEnabled = false;
+                }, () -> MinecraftServer.LOGGER.warn("Unknown entity \"" + name + "\"")));
+
+        setComment("dab", "Optimizes entity brains when", "they're far away from the player");
+    }
+
+	public static Map<String, Integer> projectileTimeouts;
+	private static void projectileTimeouts() {
+		// Set some defaults
+		getInt("entity_timeouts.SNOWBALL", -1);
+		getInt("entity_timeouts.LLAMA_SPIT", -1);
+		setComment("entity_timeouts",
+				"These values define a entity's maximum lifespan. If an",
+				"entity is in this list and it has survived for longer than",
+				"that number of ticks, then it will be removed. Setting a value to",
+				"-1 disables this feature.");
+
+		for (EntityType<?> entityType : BuiltInRegistries.ENTITY_TYPE) {
+			String type = EntityType.getKey(entityType).getPath().toUpperCase(Locale.ROOT);
+			entityType.ttl = config.getInt("entity_timeouts." + type, -1);
+		}
+	}
+
+    public static boolean throttleInactiveGoalSelectorTick = true;
+	private static void inactiveGoalSelectorThrottle() {
+		throttleInactiveGoalSelectorTick = getBoolean("inactive-goal-selector-throttle", "inactive-goal-selector-disable", throttleInactiveGoalSelectorTick,
+				"Throttles the AI goal selector in entity inactive ticks.",
+				"This can improve performance by a few percent, but has minor gameplay implications.");
+	}
+
+	public static boolean allowEndCrystalRespawn = true;
+	private static void allowEndCrystalRespawn() {
+		allowEndCrystalRespawn = getBoolean("allow-end-crystal-respawn", allowEndCrystalRespawn,
+				"Allows end crystals to respawn the ender dragon.",
+				"On servers that expect end crystal fights in the end dimension, disabling this",
+				"will prevent the server from performing an expensive search to attempt respawning",
+				"the ender dragon whenever a player places an end crystal.");
+	}
+
+    public static URI profileWebUrl;
+    private static void profilerOptions() {
+        profileWebUrl = URI.create(getString("flare.url", "https://flare.airplane.gg", "Sets the server to use for profiles."));
+        setComment("flare", "Configures Flare, the built-in profiler");
+    }
+
+    public static String accessToken;
+    private static void airplaneWebServices() {
+        accessToken = getString("web-services.token", "");
+        // todo lookup token (off-thread) and let users know if their token is valid
+        if (accessToken.length() > 0) {
+            gg.pufferfish.pufferfish.flare.FlareSetup.init(); // Pufferfish
+            SimpleCommandMap commandMap = MinecraftServer.getServer().server.getCommandMap();
+            if (commandMap.getCommand("flare") == null) {
+                commandMap.register("flare", "Pufferfish", new FlareCommand());
+            }
+        }
+
+        setComment("web-services", "Options for connecting to Pufferfish/Airplane's online utilities");
+    }
+
+    public static boolean disableMethodProfiler = true;
+	 public static boolean disableOutOfOrderChat = false;
+    private static void miscSettings() {
+		disableMethodProfiler = getBoolean("misc.disable-method-profiler", disableMethodProfiler);
+		disableOutOfOrderChat = getBoolean("misc.disable-out-of-order-chat", disableOutOfOrderChat);
+       setComment("misc", "Settings for things that don't belong elsewhere");
+    }
+}
diff --git a/src/main/java/gg/pufferfish/pufferfish/PufferfishLogger.java b/src/main/java/gg/pufferfish/pufferfish/PufferfishLogger.java
new file mode 100644
index 0000000000000000000000000000000000000000..53f2df00c6809618a9ee3d2ea72e85e8052fbcf1
--- /dev/null
+++ b/src/main/java/gg/pufferfish/pufferfish/PufferfishLogger.java
@@ -0,0 +1,16 @@
+package gg.pufferfish.pufferfish;
+
+import java.util.logging.Level;
+import java.util.logging.Logger;
+import org.bukkit.Bukkit;
+
+public class PufferfishLogger extends Logger {
+    public static final PufferfishLogger LOGGER = new PufferfishLogger();
+
+    private PufferfishLogger() {
+        super("Pufferfish", null);
+
+        setParent(Bukkit.getLogger());
+        setLevel(Level.ALL);
+    }
+}
diff --git a/src/main/java/gg/pufferfish/pufferfish/compat/ServerConfigurations.java b/src/main/java/gg/pufferfish/pufferfish/compat/ServerConfigurations.java
new file mode 100644
index 0000000000000000000000000000000000000000..f4ee2b700b3687eb9eda363bc905d8cf24dd7cff
--- /dev/null
+++ b/src/main/java/gg/pufferfish/pufferfish/compat/ServerConfigurations.java
@@ -0,0 +1,77 @@
+package gg.pufferfish.pufferfish.compat;
+
+import co.aikar.timings.TimingsManager;
+import com.google.common.io.Files;
+import org.bukkit.configuration.InvalidConfigurationException;
+import org.bukkit.configuration.file.YamlConfiguration;
+
+import java.io.ByteArrayOutputStream;
+import java.io.File;
+import java.io.FileInputStream;
+import java.io.IOException;
+import java.util.Arrays;
+import java.util.HashMap;
+import java.util.List;
+import java.util.Map;
+import java.util.Properties;
+import java.util.stream.Collectors;
+
+public class ServerConfigurations {
+
+    public static final String[] configurationFiles = new String[]{
+            "server.properties",
+            "bukkit.yml",
+            "spigot.yml",
+            // "paper.yml", // TODO: Figure out what to do with this.
+            "pufferfish.yml"
+    };
+
+    public static Map<String, String> getCleanCopies() throws IOException {
+        Map<String, String> files = new HashMap<>(configurationFiles.length);
+        for (String file : configurationFiles) {
+            files.put(file, getCleanCopy(file));
+        }
+        return files;
+    }
+
+    public static String getCleanCopy(String configName) throws IOException {
+        File file = new File(configName);
+        List<String> hiddenConfigs = TimingsManager.hiddenConfigs;
+
+        switch (Files.getFileExtension(configName)) {
+            case "properties": {
+                Properties properties = new Properties();
+                try (FileInputStream inputStream = new FileInputStream(file)) {
+                    properties.load(inputStream);
+                }
+                for (String hiddenConfig : hiddenConfigs) {
+                    properties.remove(hiddenConfig);
+                }
+                ByteArrayOutputStream outputStream = new ByteArrayOutputStream();
+                properties.store(outputStream, "");
+                return Arrays.stream(outputStream.toString()
+                                .split("\n"))
+                        .filter(line -> !line.startsWith("#"))
+                        .collect(Collectors.joining("\n"));
+            }
+            case "yml": {
+                YamlConfiguration configuration = new YamlConfiguration();
+                try {
+                    configuration.load(file);
+                } catch (InvalidConfigurationException e) {
+                    throw new IOException(e);
+                }
+                configuration.options().setHeader(null);
+                for (String key : configuration.getKeys(true)) {
+                    if (hiddenConfigs.contains(key)) {
+                        configuration.set(key, null);
+                    }
+                }
+                return configuration.saveToString();
+            }
+            default:
+                throw new IllegalArgumentException("Bad file type " + configName);
+        }
+    }
+
+}
diff --git a/src/main/java/gg/pufferfish/pufferfish/flare/CustomCategories.java b/src/main/java/gg/pufferfish/pufferfish/flare/CustomCategories.java
new file mode 100644
index 0000000000000000000000000000000000000000..401b42e29bccb5251684062f10b2e0f8b091bc95
--- /dev/null
+++ b/src/main/java/gg/pufferfish/pufferfish/flare/CustomCategories.java
@@ -0,0 +1,8 @@
+package gg.pufferfish.pufferfish.flare;
+
+import co.technove.flare.live.category.GraphCategory;
+
+public class CustomCategories {
+    public static final GraphCategory MC_PERF = new GraphCategory("MC Performance");
+    public static final GraphCategory ENTITIES_AND_CHUNKS = new GraphCategory("Entities & Chunks");
+}
diff --git a/src/main/java/gg/pufferfish/pufferfish/flare/FlareCommand.java b/src/main/java/gg/pufferfish/pufferfish/flare/FlareCommand.java
new file mode 100644
index 0000000000000000000000000000000000000000..f0f448ed34a25ac2d077c4958ffc45058208bc89
--- /dev/null
+++ b/src/main/java/gg/pufferfish/pufferfish/flare/FlareCommand.java
@@ -0,0 +1,133 @@
+package gg.pufferfish.pufferfish.flare;
+
+import co.technove.flare.exceptions.UserReportableException;
+import co.technove.flare.internal.profiling.ProfileType;
+import gg.pufferfish.pufferfish.PufferfishConfig;
+import io.papermc.paper.util.MCUtil;
+import net.kyori.adventure.text.Component;
+import net.kyori.adventure.text.event.ClickEvent;
+import net.kyori.adventure.text.format.NamedTextColor;
+import net.kyori.adventure.text.format.TextColor;
+import net.kyori.adventure.text.format.TextDecoration;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.command.Command;
+import org.bukkit.command.CommandSender;
+import org.bukkit.command.ConsoleCommandSender;
+import org.bukkit.util.StringUtil;
+import org.jetbrains.annotations.NotNull;
+
+import java.util.ArrayList;
+import java.util.Collections;
+import java.util.List;
+
+public class FlareCommand extends Command {
+
+    private static final String BASE_URL = "https://blog.airplane.gg/flare-tutorial/#setting-the-access-token";
+    private static final TextColor HEX = TextColor.fromHexString("#e3eaea");
+    private static final Component PREFIX = Component.text()
+            .append(Component.text("Flare ✈")
+                    .color(TextColor.fromHexString("#6a7eda"))
+                    .decoration(TextDecoration.BOLD, true)
+                    .append(Component.text(" ", HEX)
+                            .decoration(TextDecoration.BOLD, false)))
+            .asComponent();
+
+    public FlareCommand() {
+        super("flare", "Profile your server with Flare", "/flare", Collections.singletonList("profile"));
+        this.setPermission("airplane.flare");
+    }
+
+    @Override
+    public boolean execute(@NotNull CommandSender sender, @NotNull String commandLabel, String @NotNull [] args) {
+        if (!testPermission(sender)) return true;
+        if (PufferfishConfig.accessToken.isEmpty()) {
+            Component clickable = Component.text(BASE_URL, HEX, TextDecoration.UNDERLINED).clickEvent(ClickEvent.clickEvent(ClickEvent.Action.OPEN_URL, BASE_URL));
+
+            sender.sendMessage(PREFIX.append(Component.text("Flare currently requires an access token to use. To learn more, visit ").color(HEX).append(clickable)));
+            return true;
+        }
+
+        if (!FlareSetup.isSupported()) {
+            sender.sendMessage(PREFIX.append(
+                    Component.text("Profiling is not supported in this environment, check your startup logs for the error.", NamedTextColor.RED)));
+            return true;
+        }
+        if (ProfilingManager.isProfiling()) {
+            if (args.length == 1 && args[0].equalsIgnoreCase("status")) {
+                sender.sendMessage(PREFIX.append(Component.text("Current profile has been ran for " + ProfilingManager.getTimeRan().toString(), HEX)));
+                return true;
+            }
+            if (ProfilingManager.stop()) {
+                if (!(sender instanceof ConsoleCommandSender)) {
+                    sender.sendMessage(PREFIX.append(Component.text("Profiling has been stopped.", HEX)));
+                }
+            } else {
+                sender.sendMessage(PREFIX.append(Component.text("Profiling has already been stopped.", HEX)));
+            }
+        } else {
+            ProfileType profileType = ProfileType.ITIMER;
+            if (args.length > 0) {
+                try {
+                    profileType = ProfileType.valueOf(args[0].toUpperCase());
+                } catch (Exception e) {
+                    sender.sendMessage(PREFIX.append(Component
+                            .text("Invalid profile type ", HEX)
+                            .append(Component.text(args[0], HEX, TextDecoration.BOLD)
+                                    .append(Component.text("!", HEX)))
+                    ));
+                }
+            }
+            ProfileType finalProfileType = profileType;
+            MCUtil.scheduleAsyncTask(() -> {
+                try {
+                    if (ProfilingManager.start(finalProfileType)) {
+                        if (!(sender instanceof ConsoleCommandSender)) {
+                            sender.sendMessage(PREFIX.append(Component
+                                    .text("Flare has been started: " + ProfilingManager.getProfilingUri(), HEX)
+                                    .clickEvent(ClickEvent.openUrl(ProfilingManager.getProfilingUri()))
+                            ));
+                            sender.sendMessage(PREFIX.append(Component.text("  Run /" + commandLabel + " to stop the Flare.", HEX)));
+                        }
+                    } else {
+                        sender.sendMessage(PREFIX.append(Component
+                                .text("Flare has already been started: " + ProfilingManager.getProfilingUri(), HEX)
+                                .clickEvent(ClickEvent.openUrl(ProfilingManager.getProfilingUri()))
+                        ));
+                    }
+                } catch (UserReportableException e) {
+                    sender.sendMessage(Component.text("Flare failed to start: " + e.getUserError(), NamedTextColor.RED));
+                    if (e.getCause() != null) {
+                        MinecraftServer.LOGGER.warn("Flare failed to start", e);
+                    }
+                }
+            });
+        }
+        return true;
+    }
+
+    @Override
+    public @NotNull List<String> tabComplete(@NotNull CommandSender sender, @NotNull String alias, String @NotNull [] args) throws IllegalArgumentException {
+        List<String> list = new ArrayList<>();
+        if (ProfilingManager.isProfiling()) {
+            if (args.length == 1) {
+                String lastWord = args[0];
+                if (StringUtil.startsWithIgnoreCase("status", lastWord)) {
+                    list.add("status");
+                }
+                if (StringUtil.startsWithIgnoreCase("stop", lastWord)) {
+                    list.add("stop");
+                }
+            }
+        } else {
+            if (args.length <= 1) {
+                String lastWord = args.length == 0 ? "" : args[0];
+                for (ProfileType value : ProfileType.values()) {
+                    if (StringUtil.startsWithIgnoreCase(value.getInternalName(), lastWord)) {
+                        list.add(value.name().toLowerCase());
+                    }
+                }
+            }
+        }
+        return list;
+    }
+}
diff --git a/src/main/java/gg/pufferfish/pufferfish/flare/FlareSetup.java b/src/main/java/gg/pufferfish/pufferfish/flare/FlareSetup.java
new file mode 100644
index 0000000000000000000000000000000000000000..f33380b330aba4aa37d558ea73b4025fd61519da
--- /dev/null
+++ b/src/main/java/gg/pufferfish/pufferfish/flare/FlareSetup.java
@@ -0,0 +1,32 @@
+package gg.pufferfish.pufferfish.flare;
+
+import co.technove.flare.FlareInitializer;
+import co.technove.flare.internal.profiling.InitializationException;
+import net.minecraft.server.MinecraftServer;
+
+public class FlareSetup {
+
+    private static boolean initialized = false;
+    private static boolean supported = false;
+
+    public static void init() {
+        if (initialized) {
+            return;
+        }
+
+        initialized = true;
+        try {
+            for (String warning : FlareInitializer.initialize()) {
+                MinecraftServer.LOGGER.warn("Flare warning: {}", warning);
+            }
+            supported = true;
+        } catch (InitializationException e) {
+            MinecraftServer.LOGGER.warn("Failed to enable Flare:", e);
+        }
+    }
+
+    public static boolean isSupported() {
+        return supported;
+    }
+
+}
diff --git a/src/main/java/gg/pufferfish/pufferfish/flare/PluginLookup.java b/src/main/java/gg/pufferfish/pufferfish/flare/PluginLookup.java
new file mode 100644
index 0000000000000000000000000000000000000000..74aab5eb4b54ffbaf19b8976ffb8ca4a64584006
--- /dev/null
+++ b/src/main/java/gg/pufferfish/pufferfish/flare/PluginLookup.java
@@ -0,0 +1,44 @@
+package gg.pufferfish.pufferfish.flare;
+
+import com.google.common.cache.Cache;
+import com.google.common.cache.CacheBuilder;
+import org.bukkit.Bukkit;
+import org.bukkit.plugin.Plugin;
+import org.bukkit.plugin.java.PluginClassLoader;
+
+import java.util.Optional;
+import java.util.concurrent.TimeUnit;
+
+public class PluginLookup {
+    private static final Cache<String, String> pluginNameCache = CacheBuilder.newBuilder()
+      .expireAfterAccess(1, TimeUnit.MINUTES)
+      .maximumSize(1024)
+      .build();
+
+    public static Optional<String> getPluginForClass(String name) {
+        if (name.startsWith("net.minecraft") || name.startsWith("java.") || name.startsWith("com.mojang") ||
+          name.startsWith("com.google") || name.startsWith("it.unimi") || name.startsWith("sun")) {
+            return Optional.empty();
+        }
+
+        String existing = pluginNameCache.getIfPresent(name);
+        if (existing != null) {
+            return Optional.ofNullable(existing.isEmpty() ? null : existing);
+        }
+
+        String newValue = "";
+
+        for (Plugin plugin : Bukkit.getPluginManager().getPlugins()) {
+            ClassLoader classLoader = plugin.getClass().getClassLoader();
+            if (classLoader instanceof PluginClassLoader) {
+                if (((PluginClassLoader) classLoader)._airplane_hasClass(name)) {
+                    newValue = plugin.getName();
+                    break;
+                }
+            }
+        }
+
+        pluginNameCache.put(name, newValue);
+        return Optional.ofNullable(newValue.isEmpty() ? null : newValue);
+    }
+}
diff --git a/src/main/java/gg/pufferfish/pufferfish/flare/ProfilingManager.java b/src/main/java/gg/pufferfish/pufferfish/flare/ProfilingManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..5a77205461714ad63aa56200450bc44f9f66608c
--- /dev/null
+++ b/src/main/java/gg/pufferfish/pufferfish/flare/ProfilingManager.java
@@ -0,0 +1,139 @@
+package gg.pufferfish.pufferfish.flare;
+
+import co.technove.flare.Flare;
+import co.technove.flare.FlareAuth;
+import co.technove.flare.FlareBuilder;
+import co.technove.flare.exceptions.UserReportableException;
+import co.technove.flare.internal.profiling.ProfileType;
+import gg.pufferfish.pufferfish.PufferfishConfig;
+import gg.pufferfish.pufferfish.PufferfishLogger;
+import gg.pufferfish.pufferfish.compat.ServerConfigurations;
+import gg.pufferfish.pufferfish.flare.collectors.GCEventCollector;
+import gg.pufferfish.pufferfish.flare.collectors.StatCollector;
+import gg.pufferfish.pufferfish.flare.collectors.TPSCollector;
+import gg.pufferfish.pufferfish.flare.collectors.WorldCountCollector;
+import org.bukkit.Bukkit;
+import oshi.SystemInfo;
+import oshi.hardware.CentralProcessor;
+import oshi.hardware.GlobalMemory;
+import oshi.hardware.HardwareAbstractionLayer;
+import oshi.hardware.VirtualMemory;
+import oshi.software.os.OperatingSystem;
+
+import java.io.IOException;
+import java.net.URI;
+import java.time.Duration;
+import java.util.Objects;
+import java.util.logging.Level;
+
+public class ProfilingManager {
+
+    private static Flare currentFlare;
+
+    public static synchronized boolean isProfiling() {
+        return currentFlare != null && currentFlare.isRunning();
+    }
+
+    public static synchronized String getProfilingUri() {
+        return Objects.requireNonNull(currentFlare).getURI().map(URI::toString).orElse("Flare is not running");
+    }
+
+    public static Duration getTimeRan() {
+        Flare flare = currentFlare; // copy reference so no need to sync
+        if (flare == null) {
+            return Duration.ofMillis(0);
+        }
+        return flare.getCurrentDuration();
+    }
+
+    public static synchronized boolean start(ProfileType profileType) throws UserReportableException {
+        if (currentFlare != null && !currentFlare.isRunning()) {
+            currentFlare = null; // errored out
+        }
+        if (isProfiling()) {
+            return false;
+        }
+        if (Bukkit.isPrimaryThread()) {
+            throw new UserReportableException("Profiles should be started off-thread");
+        }
+
+        try {
+            OperatingSystem os = new SystemInfo().getOperatingSystem();
+
+            SystemInfo systemInfo = new SystemInfo();
+            HardwareAbstractionLayer hardware = systemInfo.getHardware();
+
+            CentralProcessor processor = hardware.getProcessor();
+            CentralProcessor.ProcessorIdentifier processorIdentifier = processor.getProcessorIdentifier();
+
+            GlobalMemory memory = hardware.getMemory();
+            VirtualMemory virtualMemory = memory.getVirtualMemory();
+
+            FlareBuilder builder = new FlareBuilder()
+                    .withProfileType(profileType)
+                    .withMemoryProfiling(true)
+                    .withAuth(FlareAuth.fromTokenAndUrl(PufferfishConfig.accessToken, PufferfishConfig.profileWebUrl))
+
+                    .withFiles(ServerConfigurations.getCleanCopies())
+                    .withVersion("Primary Version", Bukkit.getVersion())
+                    .withVersion("Bukkit Version", Bukkit.getBukkitVersion())
+                    .withVersion("Minecraft Version", Bukkit.getMinecraftVersion())
+
+                    .withGraphCategories(CustomCategories.ENTITIES_AND_CHUNKS, CustomCategories.MC_PERF)
+                    .withCollectors(new TPSCollector(), new WorldCountCollector(), new GCEventCollector(), new StatCollector())
+                    .withClassIdentifier(PluginLookup::getPluginForClass)
+
+                    .withHardware(new FlareBuilder.HardwareBuilder()
+                            .setCoreCount(processor.getPhysicalProcessorCount())
+                            .setThreadCount(processor.getLogicalProcessorCount())
+                            .setCpuModel(processorIdentifier.getName())
+                            .setCpuFrequency(processor.getMaxFreq())
+
+                            .setTotalMemory(memory.getTotal())
+                            .setTotalSwap(virtualMemory.getSwapTotal())
+                            .setTotalVirtual(virtualMemory.getVirtualMax())
+                    )
+
+                    .withOperatingSystem(new FlareBuilder.OperatingSystemBuilder()
+                            .setManufacturer(os.getManufacturer())
+                            .setFamily(os.getFamily())
+                            .setVersion(os.getVersionInfo().toString())
+                            .setBitness(os.getBitness())
+                    );
+
+            currentFlare = builder.build();
+        } catch (IOException e) {
+            PufferfishLogger.LOGGER.log(Level.WARNING, "Failed to read configuration files:", e);
+            throw new UserReportableException("Failed to load configuration files, check logs for further details.");
+        }
+
+        try {
+            currentFlare.start();
+        } catch (IllegalStateException e) {
+            PufferfishLogger.LOGGER.log(Level.WARNING, "Error starting Flare:", e);
+            throw new UserReportableException("Failed to start Flare, check logs for further details.");
+        }
+
+        PufferfishLogger.LOGGER.log(Level.INFO, "Flare has been started: " + getProfilingUri());
+        return true;
+    }
+
+    public static synchronized boolean stop() {
+        if (!isProfiling()) {
+            return false;
+        }
+        if (!currentFlare.isRunning()) {
+            currentFlare = null;
+            return true;
+        }
+        PufferfishLogger.LOGGER.log(Level.INFO, "Flare has been stopped: " + getProfilingUri());
+        try {
+            currentFlare.stop();
+        } catch (IllegalStateException e) {
+            PufferfishLogger.LOGGER.log(Level.WARNING, "Error occurred stopping Flare", e);
+        }
+        currentFlare = null;
+        return true;
+    }
+
+}
diff --git a/src/main/java/gg/pufferfish/pufferfish/flare/collectors/GCEventCollector.java b/src/main/java/gg/pufferfish/pufferfish/flare/collectors/GCEventCollector.java
new file mode 100644
index 0000000000000000000000000000000000000000..344d0b5277cc9fd7262566d1fa1ec7a8ac900778
--- /dev/null
+++ b/src/main/java/gg/pufferfish/pufferfish/flare/collectors/GCEventCollector.java
@@ -0,0 +1,65 @@
+package gg.pufferfish.pufferfish.flare.collectors;
+
+import co.technove.flare.Flare;
+import co.technove.flare.live.CollectorData;
+import co.technove.flare.live.EventCollector;
+import co.technove.flare.live.LiveEvent;
+import co.technove.flare.live.category.GraphCategory;
+import co.technove.flare.live.formatter.DataFormatter;
+import com.google.common.collect.ImmutableMap;
+import com.sun.management.GarbageCollectionNotificationInfo;
+
+import javax.management.ListenerNotFoundException;
+import javax.management.Notification;
+import javax.management.NotificationEmitter;
+import javax.management.NotificationListener;
+import javax.management.openmbean.CompositeData;
+import java.lang.management.GarbageCollectorMXBean;
+import java.lang.management.ManagementFactory;
+
+public class GCEventCollector extends EventCollector implements NotificationListener {
+
+    private static final CollectorData MINOR_GC = new CollectorData("builtin:gc:minor", "Minor GC", "A small pause in the program to allow Garbage Collection to run.", DataFormatter.MILLISECONDS, GraphCategory.SYSTEM);
+    private static final CollectorData MAJOR_GC = new CollectorData("builtin:gc:major", "Major GC", "A large pause in the program to allow Garbage Collection to run.", DataFormatter.MILLISECONDS, GraphCategory.SYSTEM);
+    private static final CollectorData UNKNOWN_GC = new CollectorData("builtin:gc:generic", "Major GC", "A run of the Garbage Collection.", DataFormatter.MILLISECONDS, GraphCategory.SYSTEM);
+
+    public GCEventCollector() {
+        super(MINOR_GC, MAJOR_GC, UNKNOWN_GC);
+    }
+
+    private static CollectorData fromString(String string) {
+        if (string.endsWith("minor GC")) {
+            return MINOR_GC;
+        } else if (string.endsWith("major GC")) {
+            return MAJOR_GC;
+        }
+        return UNKNOWN_GC;
+    }
+
+    @Override
+    public void start(Flare flare) {
+        for (GarbageCollectorMXBean garbageCollectorBean : ManagementFactory.getGarbageCollectorMXBeans()) {
+            NotificationEmitter notificationEmitter = (NotificationEmitter) garbageCollectorBean;
+            notificationEmitter.addNotificationListener(this, null, null);
+        }
+    }
+
+    @Override
+    public void stop(Flare flare) {
+        for (GarbageCollectorMXBean garbageCollectorBean : ManagementFactory.getGarbageCollectorMXBeans()) {
+            NotificationEmitter notificationEmitter = (NotificationEmitter) garbageCollectorBean;
+            try {
+                notificationEmitter.removeNotificationListener(this);
+            } catch (ListenerNotFoundException e) {
+            }
+        }
+    }
+
+    @Override
+    public void handleNotification(Notification notification, Object o) {
+        if (notification.getType().equals(GarbageCollectionNotificationInfo.GARBAGE_COLLECTION_NOTIFICATION)) {
+            GarbageCollectionNotificationInfo gcInfo = GarbageCollectionNotificationInfo.from((CompositeData) notification.getUserData());
+            reportEvent(new LiveEvent(fromString(gcInfo.getGcAction()), System.currentTimeMillis(), (int) gcInfo.getGcInfo().getDuration(), ImmutableMap.of()));
+        }
+    }
+}
diff --git a/src/main/java/gg/pufferfish/pufferfish/flare/collectors/StatCollector.java b/src/main/java/gg/pufferfish/pufferfish/flare/collectors/StatCollector.java
new file mode 100644
index 0000000000000000000000000000000000000000..a22c6dbae53667e4c72464fa27153aee30c7946e
--- /dev/null
+++ b/src/main/java/gg/pufferfish/pufferfish/flare/collectors/StatCollector.java
@@ -0,0 +1,41 @@
+package gg.pufferfish.pufferfish.flare.collectors;
+
+import co.technove.flare.live.CollectorData;
+import co.technove.flare.live.LiveCollector;
+import co.technove.flare.live.category.GraphCategory;
+import co.technove.flare.live.formatter.DataFormatter;
+import com.sun.management.OperatingSystemMXBean;
+import oshi.SystemInfo;
+import oshi.hardware.CentralProcessor;
+
+import java.lang.management.ManagementFactory;
+import java.time.Duration;
+
+public class StatCollector extends LiveCollector {
+
+    private static final CollectorData CPU = new CollectorData("builtin:stat:cpu", "CPU Load", "The total amount of CPU usage across all cores.", DataFormatter.PERCENT, GraphCategory.SYSTEM);
+    private static final CollectorData CPU_PROCESS = new CollectorData("builtin:stat:cpu_process", "Process CPU", "The amount of CPU being used by this process.", DataFormatter.PERCENT, GraphCategory.SYSTEM);
+    private static final CollectorData MEMORY = new CollectorData("builtin:stat:memory_used", "Memory", "The amount of memory being used currently.", DataFormatter.BYTES, GraphCategory.SYSTEM);
+    private static final CollectorData MEMORY_TOTAL = new CollectorData("builtin:stat:memory_total", "Memory Total", "The total amount of memory allocated.", DataFormatter.BYTES, GraphCategory.SYSTEM);
+
+    private final OperatingSystemMXBean bean;
+    private final CentralProcessor processor;
+
+    public StatCollector() {
+        super(CPU, CPU_PROCESS, MEMORY, MEMORY_TOTAL);
+        this.interval = Duration.ofSeconds(5);
+
+        this.bean = (OperatingSystemMXBean) ManagementFactory.getOperatingSystemMXBean();
+        this.processor = new SystemInfo().getHardware().getProcessor();
+    }
+
+    @Override
+    public void run() {
+        Runtime runtime = Runtime.getRuntime();
+
+        this.report(CPU, this.processor.getSystemLoadAverage(1)[0] / 100); // percentage
+        this.report(CPU_PROCESS, this.bean.getProcessCpuLoad());
+        this.report(MEMORY, runtime.totalMemory() - runtime.freeMemory());
+        this.report(MEMORY_TOTAL, runtime.totalMemory());
+    }
+}
diff --git a/src/main/java/gg/pufferfish/pufferfish/flare/collectors/TPSCollector.java b/src/main/java/gg/pufferfish/pufferfish/flare/collectors/TPSCollector.java
new file mode 100644
index 0000000000000000000000000000000000000000..40447d00aefb5ffedb8a2ee87155a04088f0649f
--- /dev/null
+++ b/src/main/java/gg/pufferfish/pufferfish/flare/collectors/TPSCollector.java
@@ -0,0 +1,31 @@
+package gg.pufferfish.pufferfish.flare.collectors;
+
+import co.technove.flare.live.CollectorData;
+import co.technove.flare.live.LiveCollector;
+import co.technove.flare.live.formatter.SuffixFormatter;
+import gg.pufferfish.pufferfish.flare.CustomCategories;
+import net.minecraft.server.MinecraftServer;
+import org.bukkit.Bukkit;
+
+import java.time.Duration;
+import java.util.Arrays;
+
+public class TPSCollector extends LiveCollector {
+    private static final CollectorData TPS = new CollectorData("airplane:tps", "TPS", "Ticks per second, or how fast the server updates. For a smooth server this should be a constant 20TPS.", SuffixFormatter.of("TPS"), CustomCategories.MC_PERF);
+    private static final CollectorData MSPT = new CollectorData("airplane:mspt", "MSPT", "Milliseconds per tick, which can show how well your server is performing. This value should always be under 50mspt.", SuffixFormatter.of("mspt"), CustomCategories.MC_PERF);
+
+    public TPSCollector() {
+        super(TPS, MSPT);
+
+        this.interval = Duration.ofSeconds(5);
+    }
+
+    @Override
+    public void run() {
+        long[] times = MinecraftServer.getServer().tickTimes5s.getTimes();
+        double mspt = ((double) Arrays.stream(times).sum() / (double) times.length) * 1.0E-6D;
+
+        this.report(TPS, Math.min(20D, Math.round(Bukkit.getServer().getTPS()[0] * 100d) / 100d));
+        this.report(MSPT, (double) Math.round(mspt * 100d) / 100d);
+    }
+}
diff --git a/src/main/java/gg/pufferfish/pufferfish/flare/collectors/WorldCountCollector.java b/src/main/java/gg/pufferfish/pufferfish/flare/collectors/WorldCountCollector.java
new file mode 100644
index 0000000000000000000000000000000000000000..63947f177d13c0e2b357e5c40a398c3e9dc5ca2c
--- /dev/null
+++ b/src/main/java/gg/pufferfish/pufferfish/flare/collectors/WorldCountCollector.java
@@ -0,0 +1,44 @@
+package gg.pufferfish.pufferfish.flare.collectors;
+
+import co.technove.flare.live.CollectorData;
+import co.technove.flare.live.LiveCollector;
+import co.technove.flare.live.formatter.SuffixFormatter;
+import gg.pufferfish.pufferfish.flare.CustomCategories;
+import org.bukkit.Bukkit;
+import org.bukkit.World;
+
+import java.time.Duration;
+
+public class WorldCountCollector extends LiveCollector {
+
+    private static final CollectorData PLAYER_COUNT = new CollectorData("airplane:world:playercount", "Player Count", "The number of players currently on the server.", new SuffixFormatter(" Player", " Players"), CustomCategories.ENTITIES_AND_CHUNKS);
+    private static final CollectorData ENTITY_COUNT = new CollectorData("airplane:world:entitycount", "Entity Count", "The number of entities in all worlds", new SuffixFormatter(" Entity", " Entities"), CustomCategories.ENTITIES_AND_CHUNKS);
+    private static final CollectorData CHUNK_COUNT = new CollectorData("airplane:world:chunkcount", "Chunk Count", "The number of chunks currently loaded.", new SuffixFormatter(" Chunk", " Chunks"), CustomCategories.ENTITIES_AND_CHUNKS);
+    private static final CollectorData TILE_ENTITY_COUNT = new CollectorData("airplane:world:blockentitycount", "Block Entity Count", "The number of block entities currently loaded.", new SuffixFormatter(" Block Entity", " Block Entities"), CustomCategories.ENTITIES_AND_CHUNKS);
+
+    public WorldCountCollector() {
+        super(PLAYER_COUNT, ENTITY_COUNT, CHUNK_COUNT, TILE_ENTITY_COUNT);
+
+        this.interval = Duration.ofSeconds(5);
+    }
+
+    @Override
+    public void run() {
+        int entities = 0;
+        int chunkCount = 0;
+        int tileEntityCount = 0;
+
+        if (!Bukkit.isStopping()) {
+            for (World world : Bukkit.getWorlds()) {
+                entities += world.getEntityCount();
+                chunkCount += world.getChunkCount();
+                tileEntityCount += world.getTileEntityCount();
+            }
+        }
+
+        this.report(PLAYER_COUNT, Bukkit.getOnlinePlayers().size());
+        this.report(ENTITY_COUNT, entities);
+        this.report(CHUNK_COUNT, chunkCount);
+        this.report(TILE_ENTITY_COUNT, tileEntityCount);
+    }
+}
diff --git a/src/main/java/gg/pufferfish/pufferfish/sentry/PufferfishSentryAppender.java b/src/main/java/gg/pufferfish/pufferfish/sentry/PufferfishSentryAppender.java
new file mode 100644
index 0000000000000000000000000000000000000000..3cf3b91a0d5f9f909679e2e86ddd5705247762aa
--- /dev/null
+++ b/src/main/java/gg/pufferfish/pufferfish/sentry/PufferfishSentryAppender.java
@@ -0,0 +1,130 @@
+package gg.pufferfish.pufferfish.sentry;
+
+import com.google.common.reflect.TypeToken;
+import com.google.gson.Gson;
+import io.sentry.Breadcrumb;
+import io.sentry.Sentry;
+import io.sentry.SentryEvent;
+import io.sentry.SentryLevel;
+import io.sentry.protocol.Message;
+import io.sentry.protocol.User;
+import org.apache.logging.log4j.Level;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Marker;
+import org.apache.logging.log4j.core.LogEvent;
+import org.apache.logging.log4j.core.Logger;
+import org.apache.logging.log4j.core.appender.AbstractAppender;
+import org.apache.logging.log4j.core.filter.AbstractFilter;
+
+import java.util.Map;
+
+public class PufferfishSentryAppender extends AbstractAppender {
+
+    private static final org.apache.logging.log4j.Logger logger = LogManager.getLogger(PufferfishSentryAppender.class);
+    private static final Gson GSON = new Gson();
+
+    public PufferfishSentryAppender() {
+        super("PufferfishSentryAdapter", new SentryFilter(), null, false, null);
+    }
+
+    @Override
+    public void append(LogEvent logEvent) {
+        if (logEvent.getThrown() != null && logEvent.getLevel().isMoreSpecificThan(Level.WARN)) {
+            try {
+                logException(logEvent);
+            } catch (Exception e) {
+                logger.warn("Failed to log event with sentry", e);
+            }
+        } else {
+            try {
+                logBreadcrumb(logEvent);
+            } catch (Exception e) {
+                logger.warn("Failed to log event with sentry", e);
+            }
+        }
+    }
+
+    private void logException(LogEvent e) {
+        SentryEvent event = new SentryEvent(e.getThrown());
+
+        Message sentryMessage = new Message();
+        sentryMessage.setMessage(e.getMessage().getFormattedMessage());
+
+        event.setMessage(sentryMessage);
+        event.setThrowable(e.getThrown());
+        event.setLevel(getLevel(e.getLevel()));
+        event.setLogger(e.getLoggerName());
+        event.setTransaction(e.getLoggerName());
+        event.setExtra("thread_name", e.getThreadName());
+
+        boolean hasContext = e.getContextData() != null;
+
+        if (hasContext && e.getContextData().containsKey("pufferfishsentry_playerid")) {
+            User user = new User();
+            user.setId(e.getContextData().getValue("pufferfishsentry_playerid"));
+            user.setUsername(e.getContextData().getValue("pufferfishsentry_playername"));
+            event.setUser(user);
+        }
+
+        if (hasContext && e.getContextData().containsKey("pufferfishsentry_pluginname")) {
+            event.setExtra("plugin.name", e.getContextData().getValue("pufferfishsentry_pluginname"));
+            event.setExtra("plugin.version", e.getContextData().getValue("pufferfishsentry_pluginversion"));
+            event.setTransaction(e.getContextData().getValue("pufferfishsentry_pluginname"));
+        }
+
+        if (hasContext && e.getContextData().containsKey("pufferfishsentry_eventdata")) {
+            Map<String, String> eventFields = GSON.fromJson((String) e.getContextData().getValue("pufferfishsentry_eventdata"), new TypeToken<Map<String, String>>() {}.getType());
+            if (eventFields != null) {
+                event.setExtra("event", eventFields);
+            }
+        }
+
+        Sentry.captureEvent(event);
+    }
+
+    private void logBreadcrumb(LogEvent e) {
+        Breadcrumb breadcrumb = new Breadcrumb();
+
+        breadcrumb.setLevel(getLevel(e.getLevel()));
+        breadcrumb.setCategory(e.getLoggerName());
+        breadcrumb.setType(e.getLoggerName());
+        breadcrumb.setMessage(e.getMessage().getFormattedMessage());
+
+        Sentry.addBreadcrumb(breadcrumb);
+    }
+
+    private SentryLevel getLevel(Level level) {
+        return switch (level.getStandardLevel()) {
+            case TRACE, DEBUG -> SentryLevel.DEBUG;
+            case WARN -> SentryLevel.WARNING;
+            case ERROR -> SentryLevel.ERROR;
+            case FATAL -> SentryLevel.FATAL;
+            default -> SentryLevel.INFO;
+        };
+    }
+
+    private static class SentryFilter extends AbstractFilter {
+
+        @Override
+        public Result filter(Logger logger, org.apache.logging.log4j.Level level, Marker marker, String msg,
+                             Object... params) {
+            return this.filter(logger.getName());
+        }
+
+        @Override
+        public Result filter(Logger logger, org.apache.logging.log4j.Level level, Marker marker, Object msg, Throwable t) {
+            return this.filter(logger.getName());
+        }
+
+        @Override
+        public Result filter(LogEvent event) {
+            return this.filter(event == null ? null : event.getLoggerName());
+        }
+
+        private Result filter(String loggerName) {
+            return loggerName != null && loggerName.startsWith("gg.castaway.pufferfish.sentry") ? Result.DENY
+                    : Result.NEUTRAL;
+        }
+
+    }
+}
diff --git a/src/main/java/gg/pufferfish/pufferfish/sentry/SentryManager.java b/src/main/java/gg/pufferfish/pufferfish/sentry/SentryManager.java
new file mode 100644
index 0000000000000000000000000000000000000000..993de653e656255e102de7c1576fdd3f8e819776
--- /dev/null
+++ b/src/main/java/gg/pufferfish/pufferfish/sentry/SentryManager.java
@@ -0,0 +1,38 @@
+package gg.pufferfish.pufferfish.sentry;
+
+import gg.pufferfish.pufferfish.PufferfishConfig;
+import io.sentry.Sentry;
+import org.apache.logging.log4j.LogManager;
+import org.apache.logging.log4j.Logger;
+
+public final class SentryManager {
+
+    private static final Logger LOGGER = LogManager.getLogger(SentryManager.class);
+
+    private SentryManager() {
+    }
+
+    private static boolean initialized = false;
+
+    public static synchronized void init() {
+        if (initialized) {
+            return;
+        }
+        try {
+            initialized = true;
+
+            Sentry.init(options -> {
+                options.setDsn(PufferfishConfig.sentryDsn);
+                options.setMaxBreadcrumbs(100);
+            });
+
+            PufferfishSentryAppender appender = new PufferfishSentryAppender();
+            appender.start();
+            ((org.apache.logging.log4j.core.Logger) LogManager.getRootLogger()).addAppender(appender);
+            LOGGER.info("Sentry logging successfully started");
+        } catch (Throwable throwable) {
+            LOGGER.warn("Failed to initialize sentry", throwable);
+            initialized = false;
+        }
+    }
+}
diff --git a/src/main/java/gg/pufferfish/pufferfish/util/AsyncExecutor.java b/src/main/java/gg/pufferfish/pufferfish/util/AsyncExecutor.java
new file mode 100644
index 0000000000000000000000000000000000000000..8e5323d5d9af25c8a85c4b34a6be76cfc54384cf
--- /dev/null
+++ b/src/main/java/gg/pufferfish/pufferfish/util/AsyncExecutor.java
@@ -0,0 +1,73 @@
+package gg.pufferfish.pufferfish.util;
+
+import com.google.common.collect.Queues;
+import gg.pufferfish.pufferfish.PufferfishLogger;
+import java.util.Queue;
+import java.util.concurrent.locks.Condition;
+import java.util.concurrent.locks.Lock;
+import java.util.concurrent.locks.ReentrantLock;
+import java.util.logging.Level;
+
+public class AsyncExecutor implements Runnable {
+	
+	private final Queue<Runnable> jobs = Queues.newArrayDeque();
+	private final Lock mutex = new ReentrantLock();
+	private final Condition cond = mutex.newCondition();
+	private final Thread thread;
+	private volatile boolean killswitch = false;
+	
+	public AsyncExecutor(String threadName) {
+		this.thread = new Thread(this, threadName);
+	}
+	
+	public void start() {
+		thread.start();
+	}
+	
+	public void kill() {
+		killswitch = true;
+		cond.signalAll();
+	}
+	
+	public void submit(Runnable runnable) {
+		mutex.lock();
+		try {
+			jobs.offer(runnable);
+			cond.signalAll();
+		} finally {
+			mutex.unlock();
+		}
+	}
+	
+	@Override
+	public void run() {
+		while (!killswitch) {
+			try {
+				Runnable runnable = takeRunnable();
+				if (runnable != null) {
+					runnable.run();
+				}
+			} catch (InterruptedException e) {
+				Thread.currentThread().interrupt();
+			} catch (Exception e) {
+				PufferfishLogger.LOGGER.log(Level.SEVERE, e, () -> "Failed to execute async job for thread " + thread.getName());
+			}
+		}
+	}
+	
+	private Runnable takeRunnable() throws InterruptedException {
+		mutex.lock();
+		try {
+			while (jobs.isEmpty() && !killswitch) {
+				cond.await();
+			}
+			
+			if (jobs.isEmpty()) return null; // We've set killswitch
+			
+			return jobs.remove();
+		} finally {
+			mutex.unlock();
+		}
+	}
+	
+}
diff --git a/src/main/java/net/minecraft/network/chat/SignedMessageChain.java b/src/main/java/net/minecraft/network/chat/SignedMessageChain.java
index 300929a406905f5ff1ede664d5b99fb0938d4d2e..01a6b1135420ea659d092ddca499f281d7240054 100644
--- a/src/main/java/net/minecraft/network/chat/SignedMessageChain.java
+++ b/src/main/java/net/minecraft/network/chat/SignedMessageChain.java
@@ -45,7 +45,7 @@ public class SignedMessageChain {
                     SignedMessageLink signedMessageLink = SignedMessageChain.this.nextLink;
                     if (signedMessageLink == null) {
                         throw new SignedMessageChain.DecodeException(SignedMessageChain.DecodeException.CHAIN_BROKEN);
-                    } else if (body.timeStamp().isBefore(SignedMessageChain.this.lastTimeStamp)) {
+                    } else if (!gg.pufferfish.pufferfish.PufferfishConfig.disableOutOfOrderChat && body.timeStamp().isBefore(SignedMessageChain.this.lastTimeStamp)) { // Pufferfish
                         this.setChainBroken();
                         throw new SignedMessageChain.DecodeException(SignedMessageChain.DecodeException.OUT_OF_ORDER_CHAT, org.bukkit.event.player.PlayerKickEvent.Cause.OUT_OF_ORDER_CHAT); // Paper - kick event causes
                     } else {
diff --git a/src/main/java/net/minecraft/server/MinecraftServer.java b/src/main/java/net/minecraft/server/MinecraftServer.java
index 696d075ca2883f3c37e35f983c4d020e5db89d16..e568b13a1fbd8e684a2dc8d0b803a0a9d1d4f380 100644
--- a/src/main/java/net/minecraft/server/MinecraftServer.java
+++ b/src/main/java/net/minecraft/server/MinecraftServer.java
@@ -323,6 +323,8 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     public volatile boolean abnormalExit = false; // Paper
     public static final long SERVER_INIT = System.nanoTime(); // Paper - Lag compensation
 
+    public gg.pufferfish.pufferfish.util.AsyncExecutor mobSpawnExecutor = new gg.pufferfish.pufferfish.util.AsyncExecutor("MobSpawning"); // Pufferfish - optimize mob spawning
+
     public static <S extends MinecraftServer> S spin(Function<Thread, S> serverFactory) {
         AtomicReference<S> atomicreference = new AtomicReference();
         Thread thread = new ca.spottedleaf.moonrise.common.util.TickThread(() -> { // Paper - rewrite chunk system
@@ -2575,6 +2577,7 @@ public abstract class MinecraftServer extends ReentrantBlockableEventLoop<TickTa
     }
 
     public ProfilerFiller getProfiler() {
+        if (gg.pufferfish.pufferfish.PufferfishConfig.disableMethodProfiler) return net.minecraft.util.profiling.InactiveProfiler.INSTANCE;
         return this.profiler;
     }
 
diff --git a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
index dd56c8e041116ef3602a9f89c998c8208ab89b51..bcf035729e5471ead26123d46bb004bdc5a80c36 100644
--- a/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
+++ b/src/main/java/net/minecraft/server/dedicated/DedicatedServer.java
@@ -239,6 +239,8 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
         this.server.spark.registerCommandBeforePlugins(this.server); // Paper - spark
         com.destroystokyo.paper.Metrics.PaperMetrics.startMetrics(); // Paper - start metrics
         com.destroystokyo.paper.VersionHistoryManager.INSTANCE.getClass(); // Paper - load version history now
+        gg.pufferfish.pufferfish.PufferfishConfig.load(); // Pufferfish
+        gg.pufferfish.pufferfish.PufferfishCommand.init(); // Pufferfish
 
         this.setPvpAllowed(dedicatedserverproperties.pvp);
         this.setFlightAllowed(dedicatedserverproperties.allowFlight);
@@ -359,6 +361,11 @@ public class DedicatedServer extends MinecraftServer implements ServerInterface
                 DedicatedServer.LOGGER.info("JMX monitoring enabled");
             }
 
+            // Pufferfish start - async mob spawning
+            if (gg.pufferfish.pufferfish.PufferfishConfig.enableAsyncMobSpawning) {
+                this.mobSpawnExecutor.start();
+            }
+            // Pufferfish end
             return true;
         }
     }
diff --git a/src/main/java/net/minecraft/server/level/ChunkMap.java b/src/main/java/net/minecraft/server/level/ChunkMap.java
index af8cb316ac169aa8d98a88765b85bb013b9ba961..25d53662a4982a289e67dceba172b5c6e7f9b3ee 100644
--- a/src/main/java/net/minecraft/server/level/ChunkMap.java
+++ b/src/main/java/net/minecraft/server/level/ChunkMap.java
@@ -1283,21 +1283,29 @@ public class ChunkMap extends ChunkStorage implements ChunkHolder.PlayerProvider
         }
 
         private int getEffectiveRange() {
-            int i = this.range;
-            Iterator iterator = this.entity.getIndirectPassengers().iterator();
+            return this.scaledRange(getHighestRange(this.entity, this.range));
+            // Pufferfish end - remove iterators and streams
+        }
 
-            while (iterator.hasNext()) {
-                Entity entity = (Entity) iterator.next();
+        // Pufferfish start - remove iterators and streams
+        private static int getHighestRange(Entity parent, int i) {
+            List<Entity> passengers = parent.getPassengers();
+
+            for (int k = 0, size = passengers.size(); k < size; k++) {
+                Entity entity = passengers.get(k);
                 int j = entity.getType().clientTrackingRange() * 16;
                 j = org.spigotmc.TrackingRange.getEntityTrackingRange(entity, j); // Paper
 
                 if (j > i) {
                     i = j;
                 }
+
+                i = getHighestRange(entity, i);
             }
 
-            return this.scaledRange(i);
+            return i;
         }
+        // Pufferfish end
 
         public void updatePlayers(List<ServerPlayer> players) {
             Iterator iterator = players.iterator();
diff --git a/src/main/java/net/minecraft/server/level/DistanceManager.java b/src/main/java/net/minecraft/server/level/DistanceManager.java
index 2d2596f04f5addac38037a14a02c6e0622d0c485..f05579067598bfc5c26b0f94b2fbf376cfd5ae0c 100644
--- a/src/main/java/net/minecraft/server/level/DistanceManager.java
+++ b/src/main/java/net/minecraft/server/level/DistanceManager.java
@@ -66,22 +66,28 @@ public abstract class DistanceManager implements ca.spottedleaf.moonrise.patches
 
     @Override
     public final void moonrise$addPlayer(final ServerPlayer player, final SectionPos pos) {
+        synchronized (this.spawnChunkTracker) { // Pufferfish - async mob spawning
         this.spawnChunkTracker.add(player, pos.x(), pos.z(), ca.spottedleaf.moonrise.patches.chunk_tick_iteration.ChunkTickConstants.PLAYER_SPAWN_TRACK_RANGE);
+        } // Pufferfish - async mob spawning
     }
 
     @Override
     public final void moonrise$removePlayer(final ServerPlayer player, final SectionPos pos) {
+        synchronized (this.spawnChunkTracker) { // Pufferfish - async mob spawning
         this.spawnChunkTracker.remove(player);
+        } // Pufferfish - async mob spawning
     }
 
     @Override
     public final void moonrise$updatePlayer(final ServerPlayer player,
                                             final SectionPos oldPos, final SectionPos newPos,
                                             final boolean oldIgnore, final boolean newIgnore) {
+        synchronized (this.spawnChunkTracker) { // Pufferfish - async mob spawning
         if (newIgnore) {
             this.spawnChunkTracker.remove(player);
         } else {
             this.spawnChunkTracker.addOrUpdate(player, newPos.x(), newPos.z(), ca.spottedleaf.moonrise.patches.chunk_tick_iteration.ChunkTickConstants.PLAYER_SPAWN_TRACK_RANGE);
+        } // Pufferfish - async mob spawning
         }
     }
     // Paper end - chunk tick iteration optimisation
@@ -216,11 +222,14 @@ public abstract class DistanceManager implements ca.spottedleaf.moonrise.patches
     }
 
     public int getNaturalSpawnChunkCount() {
+        // Pufferfish - async mob spawning; note: this doesn't need locking, it's never called off-thread
         return this.spawnChunkTracker.getTotalPositions(); // Paper - chunk tick iteration optimisation
     }
 
     public boolean hasPlayersNearby(long chunkPos) {
+        synchronized (this.spawnChunkTracker) { // Pufferfish - async mob spawning
         return this.spawnChunkTracker.hasObjectsNear(ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkX(chunkPos), ca.spottedleaf.moonrise.common.util.CoordinateUtils.getChunkZ(chunkPos)); // Paper - chunk tick iteration optimisation
+        }
     }
 
     public String getDebugStatus() {
diff --git a/src/main/java/net/minecraft/server/level/ServerChunkCache.java b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
index dcb5651d1d9b10b40430fb2f713beedf68336704..ee1af3ed8f3d486ea2579ea01921ec41fc7a1b4b 100644
--- a/src/main/java/net/minecraft/server/level/ServerChunkCache.java
+++ b/src/main/java/net/minecraft/server/level/ServerChunkCache.java
@@ -128,6 +128,9 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
     // Paper end - rewrite chunk system
     private ServerChunkCache.ChunkAndHolder[] iterationCopy; // Paper - chunk tick iteration optimisations
 
+    public boolean firstRunSpawnCounts = true; // Pufferfish - async mob spawning
+    public final java.util.concurrent.atomic.AtomicBoolean spawnCountsReady = new java.util.concurrent.atomic.AtomicBoolean(false); // Pufferfish - async mob spawning
+
     public ServerChunkCache(ServerLevel world, LevelStorageSource.LevelStorageAccess session, DataFixer dataFixer, StructureTemplateManager structureTemplateManager, Executor workerExecutor, ChunkGenerator chunkGenerator, int viewDistance, int simulationDistance, boolean dsync, ChunkProgressListener worldGenerationProgressListener, ChunkStatusUpdateListener chunkStatusChangeListener, Supplier<DimensionDataStorage> persistentStateManagerFactory) {
         this.level = world;
         this.mainThreadProcessor = new ServerChunkCache.MainThreadExecutor(world);
@@ -461,6 +464,8 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
                 int naturalSpawnChunkCount = k;
                 NaturalSpawner.SpawnState spawnercreature_d; // moved down
                 if ((this.spawnFriendlies || this.spawnEnemies) && this.level.paperConfig().entities.spawning.perPlayerMobSpawns) { // don't count mobs when animals and monsters are disabled
+                    // Pufferfish start - async mob spawning: moved down when async processing
+                    if (!gg.pufferfish.pufferfish.PufferfishConfig.enableAsyncMobSpawning) {
                     // re-set mob counts
                     for (ServerPlayer player : this.level.players) {
                         // Paper start - per player mob spawning backoff
@@ -475,14 +480,19 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
                         }
                         // Paper end - per player mob spawning backoff
                     }
-                    spawnercreature_d = NaturalSpawner.createState(naturalSpawnChunkCount, this.level.getAllEntities(), this::getFullChunk, null, true);
+                    this.lastSpawnState = NaturalSpawner.createState(naturalSpawnChunkCount, this.level.getAllEntities(), this::getFullChunk, null, true);
+                    }
+                    // Pufferfish end - async mob spawning
                 } else {
-                    spawnercreature_d = NaturalSpawner.createState(naturalSpawnChunkCount, this.level.getAllEntities(), this::getFullChunk, !this.level.paperConfig().entities.spawning.perPlayerMobSpawns ? new LocalMobCapCalculator(this.chunkMap) : null, false);
+                    // Pufferfish start - async mob spawning: this is only implemented for per-player mob spawning so this makes everything work if this setting is disabled
+                    this.lastSpawnState = NaturalSpawner.createState(naturalSpawnChunkCount, this.level.getAllEntities(), this::getFullChunk, !this.level.paperConfig().entities.spawning.perPlayerMobSpawns ? new LocalMobCapCalculator(this.chunkMap) : null, false);
+                    this.spawnCountsReady.set(true);
+                    // Pufferfish end - async mob spawning
                 }
                 // Paper end - Optional per player mob spawns
                 this.level.timings.countNaturalMobs.stopTiming(); // Paper - timings
 
-                this.lastSpawnState = spawnercreature_d;
+                // this.lastSpawnState = spawnercreature_d; // Pufferfish - this is managed asynchronously
                 gameprofilerfiller.popPush("spawnAndTick");
                 boolean flag = this.level.getGameRules().getBoolean(GameRules.RULE_DOMOBSPAWNING) && !this.level.players().isEmpty(); // CraftBukkit
 
@@ -496,6 +506,7 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
                     entityPlayer.playerNaturallySpawnedEvent.callEvent();
                 }
                 // Paper end - PlayerNaturallySpawnCreaturesEvent
+                this.level.resetIceAndSnowTick(); // Pufferfish - reset ice & snow tick random
                 int l = this.level.getGameRules().getInt(GameRules.RULE_RANDOMTICKING);
                 boolean flag1 = this.level.ticksPerSpawnCategory.getLong(org.bukkit.entity.SpawnCategory.ANIMAL) != 0L && this.level.getLevelData().getGameTime() % this.level.ticksPerSpawnCategory.getLong(org.bukkit.entity.SpawnCategory.ANIMAL) == 0L; // CraftBukkit
                 Iterator iterator1 = list.iterator();
@@ -507,8 +518,8 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
 
                     if (true && this.chunkMap.anyPlayerCloseEnoughForSpawning(chunkcoordintpair)) { // Paper - rewrite chunk system
                         chunk1.incrementInhabitedTime(j);
-                        if (flag && (this.spawnEnemies || this.spawnFriendlies) && this.level.getWorldBorder().isWithinBounds(chunkcoordintpair) && this.chunkMap.anyPlayerCloseEnoughForSpawning(chunkcoordintpair, true)) { // Spigot
-                            NaturalSpawner.spawnForChunk(this.level, chunk1, spawnercreature_d, this.spawnFriendlies, this.spawnEnemies, flag1);
+                        if ((!gg.pufferfish.pufferfish.PufferfishConfig.enableAsyncMobSpawning || this.spawnCountsReady.get()) && flag && (this.spawnEnemies || this.spawnFriendlies) && this.level.getWorldBorder().isWithinBounds(chunkcoordintpair) && this.chunkMap.anyPlayerCloseEnoughForSpawning(chunkcoordintpair, true)) { // Spigot // Pufferfish - async mob spawning
+                            NaturalSpawner.spawnForChunk(this.level, chunk1, this.lastSpawnState, this.spawnFriendlies, this.spawnEnemies, flag1); // Pufferfish - async mob spawning
                         }
 
                         if (true) { // Paper - rewrite chunk system
@@ -552,6 +563,39 @@ public class ServerChunkCache extends ChunkSource implements ca.spottedleaf.moon
             gameprofilerfiller.pop();
             gameprofilerfiller.pop();
         }
+    
+        // Pufferfish start - async mob spawning
+        if (gg.pufferfish.pufferfish.PufferfishConfig.enableAsyncMobSpawning) {
+            // re-set mob counts
+            for (ServerPlayer player : this.level.players) {
+                // Paper start - per player mob spawning backoff
+                for (int ii = 0; ii < ServerPlayer.MOBCATEGORY_TOTAL_ENUMS; ii++) {
+                    player.mobCounts[ii] = 0;
+
+                    int newBackoff = player.mobBackoffCounts[ii] - 1; // TODO make configurable bleed // TODO use nonlinear algorithm?
+                    if (newBackoff < 0) {
+                        newBackoff = 0;
+                    }
+                    player.mobBackoffCounts[ii] = newBackoff;
+                }
+                // Paper end - per player mob spawning backoff
+            }
+            if (this.firstRunSpawnCounts) {
+                this.firstRunSpawnCounts = false;
+                this.spawnCountsReady.set(true);
+            }
+            if (this.level.paperConfig().entities.spawning.perPlayerMobSpawns && this.spawnCountsReady.getAndSet(false)) {
+                int mapped = this.distanceManager.getNaturalSpawnChunkCount();
+                this.level.getServer().mobSpawnExecutor.submit(() -> {
+                    ca.spottedleaf.moonrise.common.list.IteratorSafeOrderedReferenceSet.Iterator<Entity> objectiterator =
+                            this.level.entityTickList.entities.iterator(ca.spottedleaf.moonrise.common.list.IteratorSafeOrderedReferenceSet.ITERATOR_FLAG_SEE_ADDITIONS);
+                    this.lastSpawnState = NaturalSpawner.createState(mapped, () -> objectiterator, this::getFullChunk, null, true);
+                    objectiterator.finishedIterating();
+                    this.spawnCountsReady.set(true);
+                });
+            }
+        }
+        // Pufferfish end - async mob spawning
     }
 
     private void getFullChunk(long pos, Consumer<LevelChunk> chunkConsumer) {
diff --git a/src/main/java/net/minecraft/server/level/ServerLevel.java b/src/main/java/net/minecraft/server/level/ServerLevel.java
index c96f3dcd365bc140b1f4680ef6bd770c80f8eda1..b5d2e1bd9b03d17e9958af3778e65733c17c7342 100644
--- a/src/main/java/net/minecraft/server/level/ServerLevel.java
+++ b/src/main/java/net/minecraft/server/level/ServerLevel.java
@@ -715,6 +715,7 @@ public class ServerLevel extends Level implements WorldGenLevel, ca.spottedleaf.
             org.spigotmc.ActivationRange.activateEntities(this); // Spigot
             this.timings.entityTick.startTiming(); // Spigot
             this.entityTickList.forEach((entity) -> {
+                entity.activatedPriorityReset = false; // Pufferfish - DAB
                 if (!entity.isRemoved()) {
                     if (false && this.shouldDiscardEntity(entity)) { // CraftBukkit - We prevent spawning in general, so this butchering is not needed
                         entity.discard();
@@ -734,7 +735,20 @@ public class ServerLevel extends Level implements WorldGenLevel, ca.spottedleaf.
                             }
 
                             gameprofilerfiller.push("tick");
-                            this.guardEntityTick(this::tickNonPassenger, entity);
+                            // Pufferfish start - copied from this.guardEntityTick
+                            try {
+                                this.tickNonPassenger(entity); // Pufferfish - changed
+                                // MinecraftServer.getServer().executeMidTickTasks(); // Paper - execute chunk tasks mid tick // Pufferfish - TODO reactivate
+                            } catch (Throwable throwable) {
+                                if (throwable instanceof ThreadDeath) throw throwable; // Paper
+                                // Paper start - Prevent block entity and entity crashes
+                                final String msg = String.format("Entity threw exception at %s:%s,%s,%s", entity.level().getWorld().getName(), entity.getX(), entity.getY(), entity.getZ());
+                                MinecraftServer.LOGGER.error(msg, throwable);
+                                getCraftServer().getPluginManager().callEvent(new com.destroystokyo.paper.event.server.ServerExceptionEvent(new com.destroystokyo.paper.exception.ServerInternalException(msg, throwable))); // Paper - ServerExceptionEvent
+                                entity.discard(org.bukkit.event.entity.EntityRemoveEvent.Cause.DISCARD);
+                                // Paper end - Prevent block entity and entity crashes
+                            }
+                            // Pufferfish end
                             gameprofilerfiller.pop();
                         }
                     }
@@ -855,6 +869,14 @@ public class ServerLevel extends Level implements WorldGenLevel, ca.spottedleaf.
     }
     // Paper end - optimise random ticking
 
+    // Pufferfish start
+    private int currentIceAndSnowTick = 0;
+
+    protected void resetIceAndSnowTick() {
+        this.currentIceAndSnowTick = this.random.nextInt(16);
+    }
+    // Pufferfish end
+
     public void tickChunk(LevelChunk chunk, int randomTickSpeed) {
         ChunkPos chunkcoordintpair = chunk.getPos();
         boolean flag = this.isRaining();
@@ -863,7 +885,7 @@ public class ServerLevel extends Level implements WorldGenLevel, ca.spottedleaf.
         ProfilerFiller gameprofilerfiller = this.getProfiler();
 
         gameprofilerfiller.push("thunder");
-        if (!this.paperConfig().environment.disableThunder && flag && this.isThundering() && this.spigotConfig.thunderChance > 0 && this.random.nextInt(this.spigotConfig.thunderChance) == 0) { // Spigot // Paper - Option to disable thunder
+        if (!this.paperConfig().environment.disableThunder && flag && this.isThundering() && this.spigotConfig.thunderChance > 0 && chunk.shouldDoLightning(this.random)) { // Spigot // Paper - Option to disable thunder // Pufferfish - replace random with shouldDoLightning
             BlockPos blockposition = this.findLightningTargetAround(this.getBlockRandomPos(j, 0, k, 15));
 
             if (this.isRainingAt(blockposition)) {
@@ -895,7 +917,7 @@ public class ServerLevel extends Level implements WorldGenLevel, ca.spottedleaf.
 
         if (!this.paperConfig().environment.disableIceAndSnow) { // Paper - Option to disable ice and snow
         for (int l = 0; l < randomTickSpeed; ++l) {
-            if (this.random.nextInt(48) == 0) {
+            if ((this.currentIceAndSnowTick++ & 47) == 0) { // Pufferfish - optimize further random ticking
                 this.tickPrecipitation(this.getBlockRandomPos(j, 0, k, 15));
             }
         }
diff --git a/src/main/java/net/minecraft/server/level/ServerPlayer.java b/src/main/java/net/minecraft/server/level/ServerPlayer.java
index c396580a9cfd86ff261bed439bb4662ae88010b5..508045b063f267245256331d86daa64d44da761e 100644
--- a/src/main/java/net/minecraft/server/level/ServerPlayer.java
+++ b/src/main/java/net/minecraft/server/level/ServerPlayer.java
@@ -1404,6 +1404,7 @@ public class ServerPlayer extends net.minecraft.world.entity.player.Player imple
                 this.setServerLevel(worldserver);
                 this.connection.teleport(exit); // CraftBukkit - use internal teleport without event
                 this.connection.resetPosition();
+                this.mainSupportingBlockPos = Optional.empty(); // Pufferfish - Fix paper 9372
                 worldserver.addDuringTeleport(this);
                 worldserver1.getProfiler().pop();
                 this.triggerDimensionChangeTriggers(worldserver1);
@@ -2151,6 +2152,7 @@ public class ServerPlayer extends net.minecraft.world.entity.player.Player imple
     public void moveTo(double x, double y, double z) {
         super.moveTo(x, y, z);
         this.connection.resetPosition();
+        this.mainSupportingBlockPos = Optional.empty(); // Pufferfish - Fix paper 9372
     }
 
     @Override
@@ -2400,6 +2402,7 @@ public class ServerPlayer extends net.minecraft.world.entity.player.Player imple
 
             this.connection.send(new ClientboundSetCameraPacket(this.camera));
             this.connection.resetPosition();
+            this.mainSupportingBlockPos = Optional.empty(); // Pufferfish - Fix paper 9372
         }
 
     }
@@ -2891,6 +2894,7 @@ public class ServerPlayer extends net.minecraft.world.entity.player.Player imple
     public void forceSetPositionRotation(double x, double y, double z, float yaw, float pitch) {
         this.moveTo(x, y, z, yaw, pitch);
         this.connection.resetPosition();
+        this.mainSupportingBlockPos = Optional.empty(); // Pufferfish - Fix paper 9372
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
index befeaac4786760f6847a5945da2296a3e68dbb17..c89f128c697be891b8b65b0a60dc2de88908ee2c 100644
--- a/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
+++ b/src/main/java/net/minecraft/server/network/ServerGamePacketListenerImpl.java
@@ -1157,6 +1157,13 @@ public class ServerGamePacketListenerImpl extends ServerCommonPacketListenerImpl
 
     @Override
     public void handleEditBook(ServerboundEditBookPacket packet) {
+        // Pufferfish start - disable books
+        if (!gg.pufferfish.pufferfish.PufferfishConfig.enableBooks
+                && !this.player.getBukkitEntity().hasPermission("pufferfish.usebooks")) {
+            return;
+        }
+        // Pufferfish end - disable books
+
         // Paper start - Book size limits
         final io.papermc.paper.configuration.type.number.IntOr.Disabled pageMax = io.papermc.paper.configuration.GlobalConfiguration.get().itemValidation.bookSize.pageMax;
         if (!this.cserver.isPrimaryThread() && pageMax.enabled()) {
diff --git a/src/main/java/net/minecraft/world/CompoundContainer.java b/src/main/java/net/minecraft/world/CompoundContainer.java
index 241fec02e6869c638d3a160819b32173a081467b..af8739c1349161f3620ea37b2f6caf3e4f43a092 100644
--- a/src/main/java/net/minecraft/world/CompoundContainer.java
+++ b/src/main/java/net/minecraft/world/CompoundContainer.java
@@ -64,6 +64,23 @@ public class CompoundContainer implements Container {
         this.container2 = second;
     }
 
+    // Pufferfish start
+    @Override
+    public boolean hasEmptySlot(net.minecraft.core.Direction enumdirection) {
+        return this.container1.hasEmptySlot(null) || this.container2.hasEmptySlot(null);
+    }
+
+    @Override
+    public boolean isCompletelyFull(net.minecraft.core.Direction enumdirection) {
+        return this.container1.isCompletelyFull(null) && this.container2.isCompletelyFull(null);
+    }
+
+    @Override
+    public boolean isCompletelyEmpty(net.minecraft.core.Direction enumdirection) {
+        return this.container1.isCompletelyEmpty(null) && this.container2.isCompletelyEmpty(null);
+    }
+    // Pufferfish end
+
     @Override
     public int getContainerSize() {
         return this.container1.getContainerSize() + this.container2.getContainerSize();
diff --git a/src/main/java/net/minecraft/world/Container.java b/src/main/java/net/minecraft/world/Container.java
index 5db5ba026462ca642dcee718af732f80fadabef5..9869646d634f11b707a0c2238b6b62f89258b809 100644
--- a/src/main/java/net/minecraft/world/Container.java
+++ b/src/main/java/net/minecraft/world/Container.java
@@ -17,6 +17,64 @@ public interface Container extends Clearable {
 
     float DEFAULT_DISTANCE_BUFFER = 4.0F;
 
+    // Pufferfish start - allow the inventory to override and optimize these frequent calls
+    default boolean hasEmptySlot(@org.jetbrains.annotations.Nullable net.minecraft.core.Direction enumdirection) { // there is a slot with 0 items in it
+        if (this instanceof WorldlyContainer worldlyContainer) {
+            for (int i : worldlyContainer.getSlotsForFace(enumdirection)) {
+                if (this.getItem(i).isEmpty()) {
+                    return true;
+                }
+            }
+        } else {
+            int size = this.getContainerSize();
+            for (int i = 0; i < size; i++) {
+                if (this.getItem(i).isEmpty()) {
+                    return true;
+                }
+            }
+        }
+        return false;
+    }
+
+    default boolean isCompletelyFull(@org.jetbrains.annotations.Nullable net.minecraft.core.Direction enumdirection) { // every stack is maxed
+        if (this instanceof WorldlyContainer worldlyContainer) {
+            for (int i : worldlyContainer.getSlotsForFace(enumdirection)) {
+                ItemStack itemStack = this.getItem(i);
+                if (itemStack.getCount() < itemStack.getMaxStackSize()) {
+                    return false;
+                }
+            }
+        } else {
+            int size = this.getContainerSize();
+            for (int i = 0; i < size; i++) {
+                ItemStack itemStack = this.getItem(i);
+                if (itemStack.getCount() < itemStack.getMaxStackSize()) {
+                    return false;
+                }
+            }
+        }
+        return true;
+    }
+
+    default boolean isCompletelyEmpty(@org.jetbrains.annotations.Nullable net.minecraft.core.Direction enumdirection) {
+        if (this instanceof WorldlyContainer worldlyContainer) {
+            for (int i : worldlyContainer.getSlotsForFace(enumdirection)) {
+                if (!this.getItem(i).isEmpty()) {
+                    return false;
+                }
+            }
+        } else {
+            int size = this.getContainerSize();
+            for (int i = 0; i < size; i++) {
+                if (!this.getItem(i).isEmpty()) {
+                    return false;
+                }
+            }
+        }
+        return true;
+    }
+    // Pufferfish end
+
     int getContainerSize();
 
     boolean isEmpty();
diff --git a/src/main/java/net/minecraft/world/entity/Entity.java b/src/main/java/net/minecraft/world/entity/Entity.java
index bc45c74987974b4828201e06fc8b1f3fbc0af8b4..4cb548ea68b3845b45c720b308e9d0eabf27184c 100644
--- a/src/main/java/net/minecraft/world/entity/Entity.java
+++ b/src/main/java/net/minecraft/world/entity/Entity.java
@@ -315,7 +315,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     public double yo;
     public double zo;
     private Vec3 position;
-    private BlockPos blockPosition;
+    public BlockPos blockPosition; // Pufferfish - private -> public
     private ChunkPos chunkPosition;
     private Vec3 deltaMovement;
     private float yRot;
@@ -445,6 +445,10 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
         return this.originWorld;
     }
     // Paper end - Entity origin API
+
+    public boolean activatedPriorityReset = false; // Pufferfish - DAB
+    public int activatedPriority = gg.pufferfish.pufferfish.PufferfishConfig.maximumActivationPrio; // Pufferfish - DAB: golf score
+
     public float getBukkitYaw() {
         return this.yRot;
     }
@@ -845,6 +849,13 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     }
 
     public void tick() {
+        // Pufferfish start - entity TTL
+        if (this.type != EntityType.PLAYER && this.type.ttl >= 0 && this.tickCount >= this.type.ttl) {
+            this.discard();
+            return;
+        }
+        // Pufferfish end - entity TTL
+
         this.baseTick();
     }
 
@@ -4450,7 +4461,7 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
     }
 
     public boolean updateFluidHeightAndDoFluidPushing(TagKey<Fluid> tag, double speed) {
-        if (this.touchingUnloadedChunk()) {
+        if (false && this.touchingUnloadedChunk()) { // Pufferfish - cost of a lookup here is the same cost as below, so skip
             return false;
         } else {
             AABB axisalignedbb = this.getBoundingBox().deflate(0.001D);
@@ -4467,13 +4478,60 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
             int k1 = 0;
             BlockPos.MutableBlockPos blockposition_mutableblockposition = new BlockPos.MutableBlockPos();
 
-            for (int l1 = i; l1 < j; ++l1) {
-                for (int i2 = k; i2 < l; ++i2) {
-                    for (int j2 = i1; j2 < j1; ++j2) {
-                        blockposition_mutableblockposition.set(l1, i2, j2);
-                        FluidState fluid = this.level().getFluidState(blockposition_mutableblockposition);
+            // Pufferfish start - based off CollisionUtil.getCollisionsForBlocksOrWorldBorder
+            final int minSection = ca.spottedleaf.moonrise.common.util.WorldUtil.getMinSection(this.level);
+            final int maxSection = ca.spottedleaf.moonrise.common.util.WorldUtil.getMaxSection(this.level);
+            final int minBlock = minSection << 4;
+            final int maxBlock = (maxSection << 4) | 15;
+
+            // special cases:
+            if (k > maxBlock || l < minBlock) {
+                // no point in checking
+                return false;
+            }
+
+            int minYIterate = Math.max(minBlock, k);
+            int maxYIterate = Math.min(maxBlock, l);
+
+            int minChunkX = i >> 4;
+            int maxChunkX = j >> 4;
+
+            int minChunkZ = i1 >> 4;
+            int maxChunkZ = j1 >> 4;
+
+            for (int currChunkZ = minChunkZ; currChunkZ <= maxChunkZ; ++currChunkZ) {
+                int minZ = currChunkZ == minChunkZ ? i1 & 15 : 0; // coordinate in chunk
+                int maxZ = currChunkZ == maxChunkZ ? j1 & 15 : 16; // coordinate in chunk
+
+                for (int currChunkX = minChunkX; currChunkX <= maxChunkX; ++currChunkX) {
+                    int minX = currChunkX == minChunkX ? i & 15 : 0; // coordinate in chunk
+                    int maxX = currChunkX == maxChunkX ? j & 15 : 16; // coordinate in chunk
+
+                    net.minecraft.world.level.chunk.ChunkAccess chunk = this.level.getChunkIfLoadedImmediately(currChunkX, currChunkZ);
+                    if (chunk == null) {
+                        return false; // if we're touching an unloaded chunk then it's false
+                    }
+
+                    net.minecraft.world.level.chunk.LevelChunkSection[] sections = chunk.getSections();
+
+                    for (int i2 = minYIterate; i2 < maxYIterate; ++i2) {
+                        net.minecraft.world.level.chunk.LevelChunkSection section = sections[(i2 >> 4) - minSection];
+
+                        if (section == null || section.hasOnlyAir() || section.fluidStateCount == 0) { // if no fluids, nothing in this section
+                            // empty
+                            // skip to next section
+                            i2 = (i2 & ~(15)) + 15; // increment by 15: iterator loop increments by the extra one
+                            continue;
+                        }
+
+                        net.minecraft.world.level.chunk.PalettedContainer<BlockState> blocks = section.states;
+
+                        for (int currZ = minZ; currZ < maxZ; ++currZ) {
+                            for (int currX = minX; currX < maxX; ++currX) {
+                                FluidState fluid = blocks.get(currX & 15, i2 & 15, currZ & 15).getFluidState();
 
                         if (fluid.is(tag)) {
+                            blockposition_mutableblockposition.set((currChunkX << 4) + currX, i2, (currChunkZ << 4) + currZ);
                             double d2 = (double) ((float) i2 + fluid.getHeight(this.level(), blockposition_mutableblockposition));
 
                             if (d2 >= axisalignedbb.minY) {
@@ -4496,9 +4554,12 @@ public abstract class Entity implements SyncedDataHolder, Nameable, EntityAccess
                                 // CraftBukkit end
                             }
                         }
+                            }
+                        }
                     }
                 }
             }
+            // Pufferfish end
 
             if (vec3d.length() > 0.0D) {
                 if (k1 > 0) {
diff --git a/src/main/java/net/minecraft/world/entity/EntityType.java b/src/main/java/net/minecraft/world/entity/EntityType.java
index cb61462d4691a055a4b25f7b953609d8a154fdfe..6a19ff5b84a0ab72bb5bdc04d9b837fb2ad348de 100644
--- a/src/main/java/net/minecraft/world/entity/EntityType.java
+++ b/src/main/java/net/minecraft/world/entity/EntityType.java
@@ -326,6 +326,9 @@ public class EntityType<T extends Entity> implements FeatureElement, EntityTypeT
     private final float spawnDimensionsScale;
     private final FeatureFlagSet requiredFeatures;
 
+    public boolean dabEnabled = false; // Pufferfish
+    public int ttl = -1; // Pufferfish
+
     private static <T extends Entity> EntityType<T> register(String id, EntityType.Builder type) { // CraftBukkit - decompile error
         return (EntityType) Registry.register(BuiltInRegistries.ENTITY_TYPE, id, (EntityType<T>) type.build(id)); // CraftBukkit - decompile error
     }
diff --git a/src/main/java/net/minecraft/world/entity/LivingEntity.java b/src/main/java/net/minecraft/world/entity/LivingEntity.java
index 30f4f1254fc295442d72d50479e8af635f2fe983..71eea3665ee31d67b63ec3b69c4ba77ee169146c 100644
--- a/src/main/java/net/minecraft/world/entity/LivingEntity.java
+++ b/src/main/java/net/minecraft/world/entity/LivingEntity.java
@@ -449,7 +449,7 @@ public abstract class LivingEntity extends Entity implements Attackable {
             boolean flag = this instanceof net.minecraft.world.entity.player.Player;
 
             if (!this.level().isClientSide) {
-                if (this.isInWall()) {
+                if (shouldCheckForSuffocation() && this.isInWall()) { // Pufferfish - optimize suffocation
                     this.hurt(this.damageSources().inWall(), 1.0F);
                 } else if (flag && !this.level().getWorldBorder().isWithinBounds(this.getBoundingBox())) {
                     double d0 = this.level().getWorldBorder().getDistanceToBorder(this) + this.level().getWorldBorder().getDamageSafeZone();
@@ -1409,6 +1409,16 @@ public abstract class LivingEntity extends Entity implements Attackable {
         return this.getHealth() <= 0.0F;
     }
 
+    // Pufferfish start - optimize suffocation
+    public boolean couldPossiblyBeHurt(float amount) {
+        return !((float) this.invulnerableTime > (float) this.invulnerableDuration / 2.0F) || !(amount <= this.lastHurt);
+    }
+
+    public boolean shouldCheckForSuffocation() {
+        return !gg.pufferfish.pufferfish.PufferfishConfig.enableSuffocationOptimization || (tickCount % 10 == 0 && couldPossiblyBeHurt(1.0F));
+    }
+    // Pufferfish end
+
     @Override
     public boolean hurt(DamageSource source, float amount) {
         if (this.isInvulnerableTo(source)) {
@@ -2065,6 +2075,20 @@ public abstract class LivingEntity extends Entity implements Attackable {
         return this.lastClimbablePos;
     }
 
+
+    // Pufferfish start
+    private boolean cachedOnClimable = false;
+    private BlockPos lastClimbingPosition = null;
+
+    public boolean onClimableCached() {
+        if (!this.blockPosition().equals(this.lastClimbingPosition)) {
+            this.cachedOnClimable = this.onClimbable();
+            this.lastClimbingPosition = this.blockPosition();
+        }
+        return this.cachedOnClimable;
+    }
+    // Pufferfish end
+
     public boolean onClimbable() {
         if (this.isSpectator()) {
             return false;
diff --git a/src/main/java/net/minecraft/world/entity/Mob.java b/src/main/java/net/minecraft/world/entity/Mob.java
index 763abeea3f14f15c27d600e0bdae44b387687bb4..38f8e0c919f5a771ebb344c335e25f3767d4096f 100644
--- a/src/main/java/net/minecraft/world/entity/Mob.java
+++ b/src/main/java/net/minecraft/world/entity/Mob.java
@@ -232,14 +232,17 @@ public abstract class Mob extends LivingEntity implements EquipmentUser, Leashab
         return this.lookControl;
     }
 
+    int _pufferfish_inactiveTickDisableCounter = 0; // Pufferfish - throttle inactive goal selector ticking
+
     // Paper start
     @Override
     public void inactiveTick() {
         super.inactiveTick();
-        if (this.goalSelector.inactiveTick()) {
+        boolean isThrottled = gg.pufferfish.pufferfish.PufferfishConfig.throttleInactiveGoalSelectorTick && _pufferfish_inactiveTickDisableCounter++ % 20 != 0; // Pufferfish - throttle inactive goal selector ticking
+        if (this.goalSelector.inactiveTick(this.activatedPriority, true) && !isThrottled) { // Pufferfish - pass activated priroity // Pufferfish - throttle inactive goal selector ticking
             this.goalSelector.tick();
         }
-        if (this.targetSelector.inactiveTick()) {
+        if (this.targetSelector.inactiveTick(this.activatedPriority, true)) { // Pufferfish - pass activated priority
             this.targetSelector.tick();
         }
     }
@@ -929,16 +932,20 @@ public abstract class Mob extends LivingEntity implements EquipmentUser, Leashab
 
         if (i % 2 != 0 && this.tickCount > 1) {
             gameprofilerfiller.push("targetSelector");
+            if (this.targetSelector.inactiveTick(this.activatedPriority, false)) // Pufferfish - use this to alternate ticking
             this.targetSelector.tickRunningGoals(false);
             gameprofilerfiller.pop();
             gameprofilerfiller.push("goalSelector");
+            if (this.goalSelector.inactiveTick(this.activatedPriority, false)) // Pufferfish - use this to alternate ticking
             this.goalSelector.tickRunningGoals(false);
             gameprofilerfiller.pop();
         } else {
             gameprofilerfiller.push("targetSelector");
+            if (this.targetSelector.inactiveTick(this.activatedPriority, false)) // Pufferfish - use this to alternate ticking
             this.targetSelector.tick();
             gameprofilerfiller.pop();
             gameprofilerfiller.push("goalSelector");
+            if (this.goalSelector.inactiveTick(this.activatedPriority, false)) // Pufferfish - use this to alternate ticking
             this.goalSelector.tick();
             gameprofilerfiller.pop();
         }
diff --git a/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMap.java b/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMap.java
index 69992ebc999ea3ff9e47e4e049bcc514c01150ca..94a26b63b59886aee345ac2bf3150519a85c7b55 100644
--- a/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMap.java
+++ b/src/main/java/net/minecraft/world/entity/ai/attributes/AttributeMap.java
@@ -23,9 +23,11 @@ public class AttributeMap {
     private final Set<AttributeInstance> attributesToSync = new ObjectOpenHashSet<>();
     private final Set<AttributeInstance> attributesToUpdate = new ObjectOpenHashSet<>();
     private final AttributeSupplier supplier;
+    private final java.util.function.Function<Holder<Attribute>, AttributeInstance> createInstance; // Pufferfish
 
     public AttributeMap(AttributeSupplier defaultAttributes) {
         this.supplier = defaultAttributes;
+        this.createInstance = attribute -> this.supplier.createInstance(this::onAttributeModified, attribute); // Pufferfish
     }
 
     private void onAttributeModified(AttributeInstance instance) {
@@ -49,7 +51,7 @@ public class AttributeMap {
 
     @Nullable
     public AttributeInstance getInstance(Holder<Attribute> attribute) {
-        return this.attributes.computeIfAbsent(attribute, attributex -> this.supplier.createInstance(this::onAttributeModified, attributex));
+        return this.attributes.computeIfAbsent(attribute, this.createInstance); // Pufferfish - cache lambda, as for some reason java allocates it anyways
     }
 
     public boolean hasAttribute(Holder<Attribute> attribute) {
diff --git a/src/main/java/net/minecraft/world/entity/ai/behavior/VillagerPanicTrigger.java b/src/main/java/net/minecraft/world/entity/ai/behavior/VillagerPanicTrigger.java
index 758f62416ca9c02351348ac0d41deeb4624abc0e..e52048101b69aa5b43e60710361542821d7b03d2 100644
--- a/src/main/java/net/minecraft/world/entity/ai/behavior/VillagerPanicTrigger.java
+++ b/src/main/java/net/minecraft/world/entity/ai/behavior/VillagerPanicTrigger.java
@@ -36,7 +36,13 @@ public class VillagerPanicTrigger extends Behavior<Villager> {
 
     @Override
     protected void tick(ServerLevel world, Villager entity, long time) {
-        if (time % 100L == 0L) {
+        // Pufferfish start
+        if (entity.nextGolemPanic < 0) {
+            entity.nextGolemPanic = time + 100;
+        }
+        if (--entity.nextGolemPanic < time) {
+            entity.nextGolemPanic = -1;
+            // Pufferfish end
             entity.spawnGolemIfNeeded(world, time, 3);
         }
     }
diff --git a/src/main/java/net/minecraft/world/entity/ai/goal/GoalSelector.java b/src/main/java/net/minecraft/world/entity/ai/goal/GoalSelector.java
index 9bdbf3e9453bc3ce96d52d04b8cde0d05f7356d8..5e3bcd898b49bd5830429d8e5f14be2e5890d8f2 100644
--- a/src/main/java/net/minecraft/world/entity/ai/goal/GoalSelector.java
+++ b/src/main/java/net/minecraft/world/entity/ai/goal/GoalSelector.java
@@ -43,9 +43,12 @@ public class GoalSelector {
     }
 
     // Paper start
-    public boolean inactiveTick() {
+    public boolean inactiveTick(int tickRate, boolean inactive) { // Pufferfish start
+        if (inactive && !gg.pufferfish.pufferfish.PufferfishConfig.dearEnabled) tickRate = 4; // reset to Paper's
+        tickRate = Math.min(tickRate, 3); // 3 = newGoalRate
         this.curRate++;
-        return this.curRate % 3 == 0; // TODO newGoalRate was already unused in 1.20.4, check if this is correct
+        return this.curRate % tickRate == 0; // TODO newGoalRate was already unused in 1.20.4, check if this is correct
+        // Pufferfish end
     }
     public boolean hasTasks() {
         for (WrappedGoal task : this.availableGoals) {
diff --git a/src/main/java/net/minecraft/world/entity/ai/goal/MoveToBlockGoal.java b/src/main/java/net/minecraft/world/entity/ai/goal/MoveToBlockGoal.java
index aee0147649d458b87d92496eda0c1723ebe570d2..347fec7c7c746f7160362d6e4a68136d0bcf7d80 100644
--- a/src/main/java/net/minecraft/world/entity/ai/goal/MoveToBlockGoal.java
+++ b/src/main/java/net/minecraft/world/entity/ai/goal/MoveToBlockGoal.java
@@ -121,6 +121,13 @@ public abstract class MoveToBlockGoal extends Goal {
                 for (int m = 0; m <= l; m = m > 0 ? -m : 1 - m) {
                     for (int n = m < l && m > -l ? l : 0; n <= l; n = n > 0 ? -n : 1 - n) {
                         mutableBlockPos.setWithOffset(blockPos, m, k - 1, n);
+
+                        // Pufferfish start - if this block isn't loaded, continue
+                        if (!this.mob.level().hasChunkAt(mutableBlockPos)) {
+                            continue;
+                        }
+                        // Pufferfish ends - if this block isn't loaded, continue
+
                         if (this.mob.isWithinRestriction(mutableBlockPos) && this.isValidTarget(this.mob.level(), mutableBlockPos)) {
                             this.blockPos = mutableBlockPos;
                             this.mob.movingTarget = mutableBlockPos == BlockPos.ZERO ? null : mutableBlockPos.immutable(); // Paper
diff --git a/src/main/java/net/minecraft/world/entity/ai/targeting/TargetingConditions.java b/src/main/java/net/minecraft/world/entity/ai/targeting/TargetingConditions.java
index aecb0ad814586bfc5e56755ee14379a69388b38c..c581e8341df0144fa2e21cd08623d198498956a3 100644
--- a/src/main/java/net/minecraft/world/entity/ai/targeting/TargetingConditions.java
+++ b/src/main/java/net/minecraft/world/entity/ai/targeting/TargetingConditions.java
@@ -76,9 +76,18 @@ public class TargetingConditions {
                 }
 
                 if (this.range > 0.0) {
-                    double d = this.testInvisible ? targetEntity.getVisibilityPercent(baseEntity) : 1.0;
-                    double e = Math.max((this.useFollowRange ? this.getFollowRange(baseEntity) : this.range) * d, 2.0); // Paper - Fix MC-145656
+                    // Pufferfish start - check range before getting visibility
+                    // d = invisibility percent, e = follow range adjusted for invisibility, f = distance
                     double f = baseEntity.distanceToSqr(targetEntity.getX(), targetEntity.getY(), targetEntity.getZ());
+                    double followRangeRaw = this.useFollowRange ? this.getFollowRange(baseEntity) : this.range; // Paper - Fix MC-145656
+
+                    if (f > followRangeRaw * followRangeRaw) { // the actual follow range will always be this value or smaller, so if the distance is larger then it never will return true after getting invis
+                        return false;
+                    }
+
+                    double d = this.testInvisible ? targetEntity.getVisibilityPercent(baseEntity) : 1.0;
+                    double e = Math.max(followRangeRaw * d, 2.0D);
+                    // Pufferfish end - check range before getting visibility
                     if (f > e * e) {
                         return false;
                     }
diff --git a/src/main/java/net/minecraft/world/entity/ambient/Bat.java b/src/main/java/net/minecraft/world/entity/ambient/Bat.java
index dc27ddf5131e7398a5390a5187261d4c7fb6ccaa..e5a47fd9de1fff476cffd4305887a7079a3dcb43 100644
--- a/src/main/java/net/minecraft/world/entity/ambient/Bat.java
+++ b/src/main/java/net/minecraft/world/entity/ambient/Bat.java
@@ -239,7 +239,21 @@ public class Bat extends AmbientCreature {
         }
     }
 
+    // Pufferfish start - spooky season cache
+    private static boolean isSpookySeason = false;
+    private static final int ONE_HOUR = 20 * 60 * 60;
+    private static int lastSpookyCheck = -ONE_HOUR;
+
     private static boolean isHalloween() {
+        if (net.minecraft.server.MinecraftServer.currentTick - lastSpookyCheck > ONE_HOUR) {
+            isSpookySeason = isHalloween0();
+            lastSpookyCheck = net.minecraft.server.MinecraftServer.currentTick;
+        }
+        return isSpookySeason;
+    }
+
+    private static boolean isHalloween0() {
+        // Pufferfish end - spooky season cache
         LocalDate localdate = LocalDate.now();
         int i = localdate.get(ChronoField.DAY_OF_MONTH);
         int j = localdate.get(ChronoField.MONTH_OF_YEAR);
diff --git a/src/main/java/net/minecraft/world/entity/animal/allay/Allay.java b/src/main/java/net/minecraft/world/entity/animal/allay/Allay.java
index 69986f75d3cf729204cca0c7e5428536af31f695..e7bacabe90d55f884b2c6fcb03cb2e6a54e6728a 100644
--- a/src/main/java/net/minecraft/world/entity/animal/allay/Allay.java
+++ b/src/main/java/net/minecraft/world/entity/animal/allay/Allay.java
@@ -217,9 +217,12 @@ public class Allay extends PathfinderMob implements InventoryCarrier, VibrationS
         return 0.4F;
     }
 
+    private int behaviorTick = 0; // Pufferfish - DAB
+
     @Override
     protected void customServerAiStep() {
         this.level().getProfiler().push("allayBrain");
+        if (this.behaviorTick++ % this.activatedPriority == 0) // Pufferfish
         this.getBrain().tick((ServerLevel) this.level(), this);
         this.level().getProfiler().pop();
         this.level().getProfiler().push("allayActivityUpdate");
diff --git a/src/main/java/net/minecraft/world/entity/animal/axolotl/Axolotl.java b/src/main/java/net/minecraft/world/entity/animal/axolotl/Axolotl.java
index 01a0731e92d39c8718538244e34a271fb8717fc2..48e7c8f5ce47425e73b269916dd0ee91dbb05969 100644
--- a/src/main/java/net/minecraft/world/entity/animal/axolotl/Axolotl.java
+++ b/src/main/java/net/minecraft/world/entity/animal/axolotl/Axolotl.java
@@ -269,9 +269,12 @@ public class Axolotl extends Animal implements LerpingModel, VariantHolder<Axolo
         return true;
     }
 
+    private int behaviorTick = 0; // Pufferfish
+
     @Override
     protected void customServerAiStep() {
         this.level().getProfiler().push("axolotlBrain");
+        if (this.behaviorTick++ % this.activatedPriority == 0) // Pufferfish
         this.getBrain().tick((ServerLevel) this.level(), this);
         this.level().getProfiler().pop();
         this.level().getProfiler().push("axolotlActivityUpdate");
diff --git a/src/main/java/net/minecraft/world/entity/animal/camel/Camel.java b/src/main/java/net/minecraft/world/entity/animal/camel/Camel.java
index 8941752e4600ccd11b3fa1147b2e414785589eed..4104ad6fc8b731667752f1d76440f2fdaeb96a41 100644
--- a/src/main/java/net/minecraft/world/entity/animal/camel/Camel.java
+++ b/src/main/java/net/minecraft/world/entity/animal/camel/Camel.java
@@ -141,11 +141,14 @@ public class Camel extends AbstractHorse implements PlayerRideableJumping, Saddl
         return pose == Pose.SITTING ? Camel.SITTING_DIMENSIONS.scale(this.getAgeScale()) : super.getDefaultDimensions(pose);
     }
 
+    private int behaviorTick = 0; // Pufferfish
+
     @Override
     protected void customServerAiStep() {
         this.level().getProfiler().push("camelBrain");
         Brain<Camel> behaviorcontroller = (Brain<Camel>) this.getBrain(); // CraftBukkit - decompile error
 
+        if (this.behaviorTick++ % this.activatedPriority == 0) // Pufferfish
         behaviorcontroller.tick((ServerLevel) this.level(), this);
         this.level().getProfiler().pop();
         this.level().getProfiler().push("camelActivityUpdate");
diff --git a/src/main/java/net/minecraft/world/entity/animal/frog/Frog.java b/src/main/java/net/minecraft/world/entity/animal/frog/Frog.java
index 816977990639ec0559b652fc9666afd5046f0a5d..c717927d233edf2b2c849e0aaaa748e62f978151 100644
--- a/src/main/java/net/minecraft/world/entity/animal/frog/Frog.java
+++ b/src/main/java/net/minecraft/world/entity/animal/frog/Frog.java
@@ -181,9 +181,12 @@ public class Frog extends Animal implements VariantHolder<Holder<FrogVariant>> {
             .ifPresent(this::setVariant);
     }
 
+    private int behaviorTick = 0; // Pufferfish - DAB
+
     @Override
     protected void customServerAiStep() {
         this.level().getProfiler().push("frogBrain");
+        if (this.behaviorTick++ % this.activatedPriority == 0) // Pufferfish - DAB
         this.getBrain().tick((ServerLevel)this.level(), this);
         this.level().getProfiler().pop();
         this.level().getProfiler().push("frogActivityUpdate");
diff --git a/src/main/java/net/minecraft/world/entity/animal/frog/Tadpole.java b/src/main/java/net/minecraft/world/entity/animal/frog/Tadpole.java
index 43046f4a0cff620834ac4647efdcde227185b2ff..bd5213da69788f31e2d3106269861a0a44bf489e 100644
--- a/src/main/java/net/minecraft/world/entity/animal/frog/Tadpole.java
+++ b/src/main/java/net/minecraft/world/entity/animal/frog/Tadpole.java
@@ -83,9 +83,12 @@ public class Tadpole extends AbstractFish {
         return SoundEvents.TADPOLE_FLOP;
     }
 
+    private int behaviorTick = 0; // Pufferfish - DAB
+
     @Override
     protected void customServerAiStep() {
         this.level().getProfiler().push("tadpoleBrain");
+        if (this.behaviorTick++ % this.activatedPriority == 0) // Pufferfish - DAB
         this.getBrain().tick((ServerLevel) this.level(), this);
         this.level().getProfiler().pop();
         this.level().getProfiler().push("tadpoleActivityUpdate");
diff --git a/src/main/java/net/minecraft/world/entity/animal/goat/Goat.java b/src/main/java/net/minecraft/world/entity/animal/goat/Goat.java
index 376bcbc189008464f4d518c1e07643431ba96306..7b2e7ede41af7080222d22cf5c79ff7ef3daa063 100644
--- a/src/main/java/net/minecraft/world/entity/animal/goat/Goat.java
+++ b/src/main/java/net/minecraft/world/entity/animal/goat/Goat.java
@@ -190,9 +190,12 @@ public class Goat extends Animal {
         return (Brain<Goat>) super.getBrain(); // CraftBukkit - decompile error
     }
 
+    private int behaviorTick = 0; // Pufferfish - DAB
+
     @Override
     protected void customServerAiStep() {
         this.level().getProfiler().push("goatBrain");
+        if (this.behaviorTick++ % this.activatedPriority == 0) // Pufferfish - DAB
         this.getBrain().tick((ServerLevel) this.level(), this);
         this.level().getProfiler().pop();
         this.level().getProfiler().push("goatActivityUpdate");
diff --git a/src/main/java/net/minecraft/world/entity/animal/sniffer/Sniffer.java b/src/main/java/net/minecraft/world/entity/animal/sniffer/Sniffer.java
index fadd341ff398886a4da102eefa1beb95a63bbd6d..51a2bdcda05cec17853cec3946702c8985728afd 100644
--- a/src/main/java/net/minecraft/world/entity/animal/sniffer/Sniffer.java
+++ b/src/main/java/net/minecraft/world/entity/animal/sniffer/Sniffer.java
@@ -475,9 +475,12 @@ public class Sniffer extends Animal {
         return Brain.provider(SnifferAi.MEMORY_TYPES, SnifferAi.SENSOR_TYPES);
     }
 
+    private int behaviorTick = 0; // Pufferfish - DAB
+
     @Override
     protected void customServerAiStep() {
         this.level().getProfiler().push("snifferBrain");
+        if (this.behaviorTick++ % this.activatedPriority == 0) // Pufferfish - DAB
         this.getBrain().tick((ServerLevel) this.level(), this);
         this.level().getProfiler().popPush("snifferActivityUpdate");
         SnifferAi.updateActivity(this);
diff --git a/src/main/java/net/minecraft/world/entity/boss/wither/WitherBoss.java b/src/main/java/net/minecraft/world/entity/boss/wither/WitherBoss.java
index d3b4d492aee380dc17f4232d90eaae4f07bb9f86..042d661aef88d0e3babad971b86ec64bc7818fbd 100644
--- a/src/main/java/net/minecraft/world/entity/boss/wither/WitherBoss.java
+++ b/src/main/java/net/minecraft/world/entity/boss/wither/WitherBoss.java
@@ -154,6 +154,13 @@ public class WitherBoss extends Monster implements PowerableMob, RangedAttackMob
         this.bossEvent.setName(this.getDisplayName());
     }
 
+    // Pufferfish start - optimize suffocation
+    @Override
+    public boolean shouldCheckForSuffocation() {
+        return true;
+    }
+    // Pufferfish end - optimize suffocation
+
     @Override
     protected SoundEvent getAmbientSound() {
         return SoundEvents.WITHER_AMBIENT;
diff --git a/src/main/java/net/minecraft/world/entity/monster/EnderMan.java b/src/main/java/net/minecraft/world/entity/monster/EnderMan.java
index 828c51477cd8f35d591367b30bf4feef6a250292..d5567dc25e6aa239030b49b54a268e029a4deb57 100644
--- a/src/main/java/net/minecraft/world/entity/monster/EnderMan.java
+++ b/src/main/java/net/minecraft/world/entity/monster/EnderMan.java
@@ -320,6 +320,12 @@ public class EnderMan extends Monster implements NeutralMob {
     private boolean teleport(double x, double y, double z) {
         BlockPos.MutableBlockPos blockposition_mutableblockposition = new BlockPos.MutableBlockPos(x, y, z);
 
+        // Pufferfish start - don't teleport into unloaded chunks
+        if (this.level().getChunkIfLoadedImmediately(blockposition_mutableblockposition) == null) {
+            return false;
+        }
+        // Pufferfish end - don't teleport into unloaded chunks
+
         while (blockposition_mutableblockposition.getY() > this.level().getMinBuildHeight() && !this.level().getBlockState(blockposition_mutableblockposition).blocksMotion()) {
             blockposition_mutableblockposition.move(Direction.DOWN);
         }
diff --git a/src/main/java/net/minecraft/world/entity/monster/Zoglin.java b/src/main/java/net/minecraft/world/entity/monster/Zoglin.java
index aa458ede5bd645ebf524238179edb33f41bd683f..33e877772f5a4d2af812238b51afdb60e1afaaf3 100644
--- a/src/main/java/net/minecraft/world/entity/monster/Zoglin.java
+++ b/src/main/java/net/minecraft/world/entity/monster/Zoglin.java
@@ -231,9 +231,12 @@ public class Zoglin extends Monster implements Enemy, HoglinBase {
         this.setAggressive(this.brain.hasMemoryValue(MemoryModuleType.ATTACK_TARGET));
     }
 
+    private int behaviorTick = 0; // Pufferfish - DAB
+
     @Override
     protected void customServerAiStep() {
         this.level().getProfiler().push("zoglinBrain");
+        if (this.behaviorTick++ % this.activatedPriority == 0) // Pufferfish - DAB
         this.getBrain().tick((ServerLevel)this.level(), this);
         this.level().getProfiler().pop();
         this.updateActivity();
diff --git a/src/main/java/net/minecraft/world/entity/monster/breeze/Breeze.java b/src/main/java/net/minecraft/world/entity/monster/breeze/Breeze.java
index ee9098f311b5db7251fcaf3ca199ae51ec1f2a2a..0e550951216b5444fa90302109741cc33ab819da 100644
--- a/src/main/java/net/minecraft/world/entity/monster/breeze/Breeze.java
+++ b/src/main/java/net/minecraft/world/entity/monster/breeze/Breeze.java
@@ -226,9 +226,12 @@ public class Breeze extends Monster {
         return pos.closerThan(vec3, 4.0, 10.0);
     }
 
+    private int behaviorTick = 0; // Pufferfish - DAB
+
     @Override
     protected void customServerAiStep() {
         this.level().getProfiler().push("breezeBrain");
+        if (this.behaviorTick++ % this.activatedPriority == 0) // Pufferfish - DAB
         this.getBrain().tick((ServerLevel)this.level(), this);
         this.level().getProfiler().popPush("breezeActivityUpdate");
         BreezeAi.updateActivity(this);
diff --git a/src/main/java/net/minecraft/world/entity/monster/hoglin/Hoglin.java b/src/main/java/net/minecraft/world/entity/monster/hoglin/Hoglin.java
index d5e0c493f4c348724958193795ceb987765a465f..144efdb2be01bcf85aa9be84a324f2b3426dbcde 100644
--- a/src/main/java/net/minecraft/world/entity/monster/hoglin/Hoglin.java
+++ b/src/main/java/net/minecraft/world/entity/monster/hoglin/Hoglin.java
@@ -153,9 +153,12 @@ public class Hoglin extends Animal implements Enemy, HoglinBase {
         return (Brain<Hoglin>)super.getBrain();
     }
 
+    private int behaviorTick; // Pufferfish - DAB
+
     @Override
     protected void customServerAiStep() {
         this.level().getProfiler().push("hoglinBrain");
+        if (this.behaviorTick++ % this.activatedPriority == 0) // Pufferfish - DAB
         this.getBrain().tick((ServerLevel)this.level(), this);
         this.level().getProfiler().pop();
         HoglinAi.updateActivity(this);
diff --git a/src/main/java/net/minecraft/world/entity/monster/piglin/Piglin.java b/src/main/java/net/minecraft/world/entity/monster/piglin/Piglin.java
index bc58323801ee16fe9b63c21332144ec002a902f2..04c71dd32cd85ecec6c1ce5a6c10f0b0e4234f3c 100644
--- a/src/main/java/net/minecraft/world/entity/monster/piglin/Piglin.java
+++ b/src/main/java/net/minecraft/world/entity/monster/piglin/Piglin.java
@@ -293,9 +293,12 @@ public class Piglin extends AbstractPiglin implements CrossbowAttackMob, Invento
         return !this.cannotHunt;
     }
 
+    private int behaviorTick; // Pufferfish - DAB
+
     @Override
     protected void customServerAiStep() {
         this.level().getProfiler().push("piglinBrain");
+        if (this.behaviorTick++ % this.activatedPriority == 0) // Pufferfish - DAB
         this.getBrain().tick((ServerLevel) this.level(), this);
         this.level().getProfiler().pop();
         PiglinAi.updateActivity(this);
diff --git a/src/main/java/net/minecraft/world/entity/monster/piglin/PiglinBrute.java b/src/main/java/net/minecraft/world/entity/monster/piglin/PiglinBrute.java
index fcadd7f28ccb81bbb36e97d8b8d8a8ba3f3d6a16..50cb102617c209d04052e52daa62e104377916dd 100644
--- a/src/main/java/net/minecraft/world/entity/monster/piglin/PiglinBrute.java
+++ b/src/main/java/net/minecraft/world/entity/monster/piglin/PiglinBrute.java
@@ -104,9 +104,12 @@ public class PiglinBrute extends AbstractPiglin {
         return stack.is(Items.GOLDEN_AXE) && super.wantsToPickUp(stack);
     }
 
+    private int behaviorTick = 0; // Pufferfish - DAB
+
     @Override
     protected void customServerAiStep() {
         this.level().getProfiler().push("piglinBruteBrain");
+        if (this.behaviorTick++ % this.activatedPriority == 0) // Pufferfish - DAB
         this.getBrain().tick((ServerLevel)this.level(), this);
         this.level().getProfiler().pop();
         PiglinBruteAi.updateActivity(this);
diff --git a/src/main/java/net/minecraft/world/entity/monster/warden/Warden.java b/src/main/java/net/minecraft/world/entity/monster/warden/Warden.java
index 38bf417a9ad4647f4af24d969f3bf4fed9c4bad7..2cbacdf91eca225ed3d2eaaf490df6412fc2cdc8 100644
--- a/src/main/java/net/minecraft/world/entity/monster/warden/Warden.java
+++ b/src/main/java/net/minecraft/world/entity/monster/warden/Warden.java
@@ -272,11 +272,14 @@ public class Warden extends Monster implements VibrationSystem {
 
     }
 
+    private int behaviorTick = 0; // Pufferfish - DAB
+
     @Override
     protected void customServerAiStep() {
         ServerLevel worldserver = (ServerLevel) this.level();
 
         worldserver.getProfiler().push("wardenBrain");
+        if (this.behaviorTick++ % this.activatedPriority == 0) // Pufferfish - DAB
         this.getBrain().tick(worldserver, this);
         this.level().getProfiler().pop();
         super.customServerAiStep();
diff --git a/src/main/java/net/minecraft/world/entity/npc/Villager.java b/src/main/java/net/minecraft/world/entity/npc/Villager.java
index 7e1871401ec5e3e9a85232053490259f132aec0a..63a2cf62be00e78fc9ae205afec5c5dbe3eed2c6 100644
--- a/src/main/java/net/minecraft/world/entity/npc/Villager.java
+++ b/src/main/java/net/minecraft/world/entity/npc/Villager.java
@@ -143,6 +143,8 @@ public class Villager extends AbstractVillager implements ReputationEventHandler
         return holder.is(PoiTypes.MEETING);
     });
 
+    public long nextGolemPanic = -1; // Pufferfish
+
     public Villager(EntityType<? extends Villager> entityType, Level world) {
         this(entityType, world, VillagerType.PLAINS);
     }
@@ -246,6 +248,8 @@ public class Villager extends AbstractVillager implements ReputationEventHandler
     }
     // Spigot End
 
+    private int behaviorTick = 0; // Pufferfish
+
     @Override
     @Deprecated // Paper
     protected void customServerAiStep() {
@@ -255,7 +259,13 @@ public class Villager extends AbstractVillager implements ReputationEventHandler
     protected void customServerAiStep(final boolean inactive) {
         // Paper end
         this.level().getProfiler().push("villagerBrain");
-        if (!inactive) this.getBrain().tick((ServerLevel) this.level(), this); // Paper
+        // Pufferfish start
+        if (!inactive) {
+            if (this.behaviorTick++ % this.activatedPriority == 0) {
+                this.getBrain().tick((ServerLevel) this.level(), this); // Paper
+            }
+        }
+        // Pufferfish end
         this.level().getProfiler().pop();
         if (this.assignProfessionWhenSpawned) {
             this.assignProfessionWhenSpawned = false;
diff --git a/src/main/java/net/minecraft/world/entity/player/Inventory.java b/src/main/java/net/minecraft/world/entity/player/Inventory.java
index 6e66141dca61f777b354854b5d0bac2570b8bf3b..a4908b27d4619f9e043e9a49e1a33df7ade8b137 100644
--- a/src/main/java/net/minecraft/world/entity/player/Inventory.java
+++ b/src/main/java/net/minecraft/world/entity/player/Inventory.java
@@ -643,14 +643,14 @@ public class Inventory implements Container, Nameable {
     }
 
     public boolean contains(ItemStack stack) {
-        Iterator iterator = this.compartments.iterator();
+        // Pufferfish start - don't allocate iterators
+        for (int i = 0; i < this.compartments.size(); i++) {
 
-        while (iterator.hasNext()) {
-            List<ItemStack> list = (List) iterator.next();
-            Iterator iterator1 = list.iterator();
+            List<ItemStack> list = this.compartments.get(i);
+            for (int j = 0; j < list.size(); j++) {
 
-            while (iterator1.hasNext()) {
-                ItemStack itemstack1 = (ItemStack) iterator1.next();
+                ItemStack itemstack1 = list.get(j);
+                // Pufferfish end - don't allocate iterators
 
                 if (!itemstack1.isEmpty() && ItemStack.isSameItemSameComponents(itemstack1, stack)) {
                     return true;
@@ -662,14 +662,14 @@ public class Inventory implements Container, Nameable {
     }
 
     public boolean contains(TagKey<Item> tag) {
-        Iterator iterator = this.compartments.iterator();
+        // Pufferfish start - don't allocate iterators
+        for (int i = 0; i < this.compartments.size(); i++) {
 
-        while (iterator.hasNext()) {
-            List<ItemStack> list = (List) iterator.next();
-            Iterator iterator1 = list.iterator();
+            List<ItemStack> list = this.compartments.get(i);
+            for (int j = 0; j < list.size(); j++) {
 
-            while (iterator1.hasNext()) {
-                ItemStack itemstack = (ItemStack) iterator1.next();
+                ItemStack itemstack = list.get(j);
+                // Pufferfish end - don't allocate iterators
 
                 if (!itemstack.isEmpty() && itemstack.is(tag)) {
                     return true;
@@ -681,14 +681,14 @@ public class Inventory implements Container, Nameable {
     }
 
     public boolean contains(Predicate<ItemStack> predicate) {
-        Iterator iterator = this.compartments.iterator();
+        // Pufferfish start - don't allocate iterators
+        for (int i = 0; i < this.compartments.size(); i++) {
 
-        while (iterator.hasNext()) {
-            List<ItemStack> list = (List) iterator.next();
-            Iterator iterator1 = list.iterator();
+            List<ItemStack> list = this.compartments.get(i);
+            for (int j = 0; j < list.size(); j++) {
 
-            while (iterator1.hasNext()) {
-                ItemStack itemstack = (ItemStack) iterator1.next();
+                ItemStack itemstack = list.get(j);
+                // Pufferfish end - don't allocate iterators
 
                 if (predicate.test(itemstack)) {
                     return true;
diff --git a/src/main/java/net/minecraft/world/entity/projectile/Projectile.java b/src/main/java/net/minecraft/world/entity/projectile/Projectile.java
index 10ade433c083851d9ea4797c6ec618db122229f9..fe756ceeafd66594d76e87a6b3402fdf44f427a3 100644
--- a/src/main/java/net/minecraft/world/entity/projectile/Projectile.java
+++ b/src/main/java/net/minecraft/world/entity/projectile/Projectile.java
@@ -52,6 +52,36 @@ public abstract class Projectile extends Entity implements TraceableEntity {
         super(type, world);
     }
 
+    // Pufferfish start
+    private static int loadedThisTick = 0;
+    private static int loadedTick;
+
+    private int loadedLifetime = 0;
+    @Override
+    public void setPos(double x, double y, double z) {
+        int currentTick = net.minecraft.server.MinecraftServer.currentTick;
+        if (loadedTick != currentTick) {
+            loadedTick = currentTick;
+            loadedThisTick = 0;
+        }
+        int previousX = Mth.floor(this.getX()) >> 4, previousZ = Mth.floor(this.getZ()) >> 4;
+        int newX = Mth.floor(x) >> 4, newZ = Mth.floor(z) >> 4;
+        if (previousX != newX || previousZ != newZ) {
+            boolean isLoaded = ((net.minecraft.server.level.ServerChunkCache) this.level().getChunkSource()).getChunkAtIfLoadedImmediately(newX, newZ) != null;
+            if (!isLoaded) {
+                if (Projectile.loadedThisTick > gg.pufferfish.pufferfish.PufferfishConfig.maxProjectileLoadsPerTick) {
+                    if (++this.loadedLifetime > gg.pufferfish.pufferfish.PufferfishConfig.maxProjectileLoadsPerProjectile) {
+                        this.discard();
+                    }
+                    return;
+                }
+                Projectile.loadedThisTick++;
+            }
+        }
+        super.setPos(x, y, z);
+    }
+    // Pufferfish start
+
     public void setOwner(@Nullable Entity entity) {
         if (entity != null) {
             this.ownerUUID = entity.getUUID();
diff --git a/src/main/java/net/minecraft/world/entity/vehicle/AbstractMinecartContainer.java b/src/main/java/net/minecraft/world/entity/vehicle/AbstractMinecartContainer.java
index 9549eee0d92f322bd5232abd7e695213660c2e22..a50e665526428c4b4919fe2af954a826eaf4bbcc 100644
--- a/src/main/java/net/minecraft/world/entity/vehicle/AbstractMinecartContainer.java
+++ b/src/main/java/net/minecraft/world/entity/vehicle/AbstractMinecartContainer.java
@@ -30,6 +30,7 @@ import org.bukkit.inventory.InventoryHolder;
 
 public abstract class AbstractMinecartContainer extends AbstractMinecart implements ContainerEntity {
 
+    private gg.airplane.structs.ItemListWithBitset itemStacksOptimized; // Pufferfish
     private NonNullList<ItemStack> itemStacks;
     @Nullable
     public ResourceKey<LootTable> lootTable;
@@ -86,12 +87,12 @@ public abstract class AbstractMinecartContainer extends AbstractMinecart impleme
 
     protected AbstractMinecartContainer(EntityType<?> type, Level world) {
         super(type, world);
-        this.itemStacks = NonNullList.withSize(this.getContainerSize(), ItemStack.EMPTY); // CraftBukkit - SPIGOT-3513
+        this.clearItemStacks(); // Pufferfish
     }
 
     protected AbstractMinecartContainer(EntityType<?> type, double x, double y, double z, Level world) {
         super(type, world, x, y, z);
-        this.itemStacks = NonNullList.withSize(this.getContainerSize(), ItemStack.EMPTY); // CraftBukkit - SPIGOT-3513
+        this.clearItemStacks(); // Pufferfish
     }
 
     @Override
@@ -234,6 +235,9 @@ public abstract class AbstractMinecartContainer extends AbstractMinecart impleme
 
     @Override
     public void clearItemStacks() {
-        this.itemStacks = NonNullList.withSize(this.getContainerSize(), ItemStack.EMPTY);
+        // Pufferfish start
+        this.itemStacksOptimized = new gg.airplane.structs.ItemListWithBitset(this.getContainerSize());
+        this.itemStacks = this.itemStacksOptimized.nonNullList;
+        // Pufferfish end
     }
 }
diff --git a/src/main/java/net/minecraft/world/item/EndCrystalItem.java b/src/main/java/net/minecraft/world/item/EndCrystalItem.java
index 5f51e64cb0611a4ba6bdcdcacbcba1063a7f3a5c..639ddfa5ec0d0919b4a14d7b95cf1c583b1e090f 100644
--- a/src/main/java/net/minecraft/world/item/EndCrystalItem.java
+++ b/src/main/java/net/minecraft/world/item/EndCrystalItem.java
@@ -57,6 +57,7 @@ public class EndCrystalItem extends Item {
                         world.gameEvent((Entity) context.getPlayer(), (Holder) GameEvent.ENTITY_PLACE, blockposition1);
                         EndDragonFight enderdragonbattle = ((ServerLevel) world).getDragonFight();
 
+                        if (gg.pufferfish.pufferfish.PufferfishConfig.allowEndCrystalRespawn) // Pufferfish
                         if (enderdragonbattle != null) {
                             enderdragonbattle.tryRespawn(aboveBlockPosition); // Paper - Perf: Do crystal-portal proximity check before entity lookup
                         }
diff --git a/src/main/java/net/minecraft/world/level/Level.java b/src/main/java/net/minecraft/world/level/Level.java
index e2a0487089eb5a7bdc1433e4c75f69d8e9f9d5f9..c92fe79103e43cb5a12fc80a8e2eae8287fba861 100644
--- a/src/main/java/net/minecraft/world/level/Level.java
+++ b/src/main/java/net/minecraft/world/level/Level.java
@@ -684,6 +684,14 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     }
     // Paper end - optimise random ticking
 
+    public final gg.airplane.structs.ThreadUnsafeRandom threadUnsafeRandom = new gg.airplane.structs.ThreadUnsafeRandom(java.util.concurrent.ThreadLocalRandom.current().nextLong()); // Pufferfish - cross-thread random
+
+    // Pufferfish start - ensure these get inlined
+    private final int minBuildHeight;
+    private final int height;
+    private final int maxBuildHeight;
+    // Pufferfish end - ensure these get inlined
+
     protected Level(WritableLevelData worlddatamutable, ResourceKey<Level> resourcekey, RegistryAccess iregistrycustom, Holder<DimensionType> holder, Supplier<ProfilerFiller> supplier, boolean flag, boolean flag1, long i, int j, org.bukkit.generator.ChunkGenerator gen, org.bukkit.generator.BiomeProvider biomeProvider, org.bukkit.World.Environment env, java.util.function.Function<org.spigotmc.SpigotWorldConfig, io.papermc.paper.configuration.WorldConfiguration> paperWorldConfigCreator, java.util.concurrent.Executor executor) { // Paper - create paper world config & Anti-Xray
         this.spigotConfig = new org.spigotmc.SpigotWorldConfig(((net.minecraft.world.level.storage.PrimaryLevelData) worlddatamutable).getLevelName()); // Spigot
         this.paperConfig = paperWorldConfigCreator.apply(this.spigotConfig); // Paper - create paper world config
@@ -703,6 +711,12 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
         this.dimensionTypeRegistration = holder;
         final DimensionType dimensionmanager = (DimensionType) holder.value();
 
+        // Pufferfish start
+        this.minBuildHeight = dimensionmanager.minY();
+        this.height = dimensionmanager.height();
+        this.maxBuildHeight = this.minBuildHeight + this.height;
+        // Pufferfish end
+
         this.dimension = resourcekey;
         this.isClientSide = flag;
         if (dimensionmanager.coordinateScale() != 1.0D) {
@@ -768,10 +782,11 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
         this.tileLimiter = new org.spigotmc.TickLimiter(this.spigotConfig.tileMaxTickTime);
         this.entityLookup = new ca.spottedleaf.moonrise.patches.chunk_system.level.entity.dfl.DefaultEntityLookup(this); // Paper - rewrite chunk system
         // Paper start - optimise collisions
-        this.minSection = ca.spottedleaf.moonrise.common.util.WorldUtil.getMinSection(this);
-        this.maxSection = ca.spottedleaf.moonrise.common.util.WorldUtil.getMaxSection(this);
+        this.minSection = this.getMinBuildHeight() >> 4; // Pufferfish - inline; prevent self reference
+        this.maxSection = ((this.getMaxBuildHeight() - 1) >> 4) + 1; // Pufferfish - inline; prevent self reference
         // Paper end - optimise collisions
         this.chunkPacketBlockController = this.paperConfig().anticheat.antiXray.enabled ? new com.destroystokyo.paper.antixray.ChunkPacketBlockControllerAntiXray(this, executor) : com.destroystokyo.paper.antixray.ChunkPacketBlockController.NO_OPERATION_INSTANCE; // Paper - Anti-Xray
+        // Pufferfish - prevent SOF - TODO wait for paper to apply their patches - also remove own fields
     }
 
     // Paper start - Cancel hit for vanished players
@@ -824,6 +839,33 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
         return null;
     }
 
+    // Pufferfish start - ensure these get inlined
+    @Override
+    public final int getMaxBuildHeight() {
+        return this.maxBuildHeight;
+    }
+
+    @Override
+    public final int getMinSection() {
+        return this.minSection;
+    }
+
+    @Override
+    public final int getMaxSection() {
+        return this.maxSection;
+    }
+
+    @Override
+    public final int getMinBuildHeight() {
+        return this.minBuildHeight;
+    }
+
+    @Override
+    public final int getHeight() {
+        return this.height;
+    }
+    // Pufferfish end - ensure these get inlined
+
     // Paper start - Broken down method of raytracing for EntityLiving#hasLineOfSight, replaces BlockGetter#clip(CollisionContext)
     public net.minecraft.world.phys.BlockHitResult.Type clipDirect(Vec3 start, Vec3 end, net.minecraft.world.phys.shapes.CollisionContext context) {
         // most of this code comes from BlockGetter#clip(CollisionContext, BiFunction, Function), but removes the needless functions
@@ -1418,13 +1460,13 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     public <T extends Entity> void guardEntityTick(Consumer<T> tickConsumer, T entity) {
         try {
             tickConsumer.accept(entity);
-        } catch (Throwable throwable) {
+        } catch (Throwable throwable) { // Pufferfish - diff on change ServerLevel.tick
             if (throwable instanceof ThreadDeath) throw throwable; // Paper
             // Paper start - Prevent block entity and entity crashes
             final String msg = String.format("Entity threw exception at %s:%s,%s,%s", entity.level().getWorld().getName(), entity.getX(), entity.getY(), entity.getZ());
             MinecraftServer.LOGGER.error(msg, throwable);
             getCraftServer().getPluginManager().callEvent(new com.destroystokyo.paper.event.server.ServerExceptionEvent(new com.destroystokyo.paper.exception.ServerInternalException(msg, throwable))); // Paper - ServerExceptionEvent
-            entity.discard(org.bukkit.event.entity.EntityRemoveEvent.Cause.DISCARD);
+            entity.discard(org.bukkit.event.entity.EntityRemoveEvent.Cause.DISCARD); // Pufferfish - diff on change ServerLevel.tick
             // Paper end - Prevent block entity and entity crashes
         }
         this.moonrise$midTickTasks(); // Paper - rewrite chunk system
@@ -1944,6 +1986,11 @@ public abstract class Level implements LevelAccessor, AutoCloseable, ca.spottedl
     }
 
     public ProfilerFiller getProfiler() {
+        // Pufferfish start
+        if (gg.pufferfish.pufferfish.PufferfishConfig.disableMethodProfiler) {
+            return net.minecraft.util.profiling.InactiveProfiler.INSTANCE;
+        }
+        // Pufferfish end
         return (ProfilerFiller) this.profiler.get();
     }
 
diff --git a/src/main/java/net/minecraft/world/level/NaturalSpawner.java b/src/main/java/net/minecraft/world/level/NaturalSpawner.java
index e524b27d185da3e88668f8ef107517272860bd66..ae4c446ca19408ead11a1d775d3042c43b019699 100644
--- a/src/main/java/net/minecraft/world/level/NaturalSpawner.java
+++ b/src/main/java/net/minecraft/world/level/NaturalSpawner.java
@@ -410,10 +410,10 @@ public final class NaturalSpawner {
 
     private static BlockPos getRandomPosWithin(Level world, LevelChunk chunk) {
         ChunkPos chunkcoordintpair = chunk.getPos();
-        int i = chunkcoordintpair.getMinBlockX() + world.random.nextInt(16);
-        int j = chunkcoordintpair.getMinBlockZ() + world.random.nextInt(16);
+        int i = chunkcoordintpair.getMinBlockX() + world.threadUnsafeRandom.nextInt(16); // Pufferfish - async mob spawning
+        int j = chunkcoordintpair.getMinBlockZ() + world.threadUnsafeRandom.nextInt(16); // Pufferfish - async mob spawning
         int k = chunk.getHeight(Heightmap.Types.WORLD_SURFACE, i, j) + 1;
-        int l = Mth.randomBetweenInclusive(world.random, world.getMinBuildHeight(), k);
+        int l = Mth.randomBetweenInclusive(world.threadUnsafeRandom, world.getMinBuildHeight(), k); // Pufferfish - async mob spawning
 
         return new BlockPos(i, l, j);
     }
diff --git a/src/main/java/net/minecraft/world/level/biome/Biome.java b/src/main/java/net/minecraft/world/level/biome/Biome.java
index 90c165c890a2d998e3b0af9b4310e3995ede6f64..c3f95fd941be11b2321a38b46b79e310b1d73909 100644
--- a/src/main/java/net/minecraft/world/level/biome/Biome.java
+++ b/src/main/java/net/minecraft/world/level/biome/Biome.java
@@ -63,13 +63,8 @@ public final class Biome {
     private final BiomeGenerationSettings generationSettings;
     private final MobSpawnSettings mobSettings;
     private final BiomeSpecialEffects specialEffects;
-    private final ThreadLocal<Long2FloatLinkedOpenHashMap> temperatureCache = ThreadLocal.withInitial(() -> Util.make(() -> {
-            Long2FloatLinkedOpenHashMap long2FloatLinkedOpenHashMap = new Long2FloatLinkedOpenHashMap(1024, 0.25F) {
-                protected void rehash(int i) {
-                }
-            };
-            long2FloatLinkedOpenHashMap.defaultReturnValue(Float.NaN);
-            return long2FloatLinkedOpenHashMap;
+    private static final ThreadLocal<gg.airplane.structs.Long2FloatAgingCache> TEMPERATURE_CACHE = ThreadLocal.withInitial(() -> Util.make(() -> { // Pufferfish - improved temperature caching
+        return new gg.airplane.structs.Long2FloatAgingCache(TEMPERATURE_CACHE_SIZE); // Pufferfish - improved temperature caching
         }));
 
     Biome(Biome.ClimateSettings weather, BiomeSpecialEffects effects, BiomeGenerationSettings generationSettings, MobSpawnSettings spawnSettings) {
@@ -111,7 +106,17 @@ public final class Biome {
 
     @Deprecated
     public float getTemperature(BlockPos blockPos) {
-        return this.getHeightAdjustedTemperature(blockPos); // Paper - optimise random ticking
+        // Pufferfish start - improved temperature caching
+        gg.airplane.structs.Long2FloatAgingCache cache = TEMPERATURE_CACHE.get();
+        long longPos = blockPos.asLong();
+        float temperature = cache.getValue(longPos);
+        if (!Float.isNaN(temperature)) {
+            return temperature;
+        }
+        float calculatedTemperature = this.getHeightAdjustedTemperature(blockPos);
+        cache.putValue(longPos, calculatedTemperature);
+        return calculatedTemperature;
+        // Pufferfish end - improved temperature caching
     }
 
     public boolean shouldFreeze(LevelReader world, BlockPos blockPos) {
diff --git a/src/main/java/net/minecraft/world/level/block/entity/ChestBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/ChestBlockEntity.java
index b88aa184cd06a0485146f58a5b61a56a50911209..cb71a35e4bc5f16508d111b17e9acc71394df8b7 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/ChestBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/ChestBlockEntity.java
@@ -33,6 +33,7 @@ public class ChestBlockEntity extends RandomizableContainerBlockEntity implement
 
     private static final int EVENT_SET_OPEN_COUNT = 1;
     private NonNullList<ItemStack> items;
+    private gg.airplane.structs.ItemListWithBitset optimizedItems; // Pufferfish
     public final ContainerOpenersCounter openersCounter;
     private final ChestLidController chestLidController;
 
@@ -66,9 +67,14 @@ public class ChestBlockEntity extends RandomizableContainerBlockEntity implement
     }
     // CraftBukkit end
 
+    private final boolean isNative = getClass().equals(ChestBlockEntity.class); // Pufferfish
+
     protected ChestBlockEntity(BlockEntityType<?> type, BlockPos pos, BlockState state) {
         super(type, pos, state);
-        this.items = NonNullList.withSize(27, ItemStack.EMPTY);
+        // Pufferfish start
+        this.optimizedItems = new gg.airplane.structs.ItemListWithBitset(27);
+        this.items = this.optimizedItems.nonNullList;
+        // Pufferfish end
         this.openersCounter = new ContainerOpenersCounter() {
             @Override
             protected void onOpen(Level world, BlockPos pos, BlockState state) {
@@ -103,6 +109,23 @@ public class ChestBlockEntity extends RandomizableContainerBlockEntity implement
         this(BlockEntityType.CHEST, pos, state);
     }
 
+    // Pufferfish start
+    @Override
+    public boolean hasEmptySlot(Direction enumdirection) {
+        return isNative ? !this.optimizedItems.hasFullStacks() : super.hasEmptySlot(enumdirection);
+    }
+
+    @Override
+    public boolean isCompletelyFull(Direction enumdirection) {
+        return isNative ? this.optimizedItems.hasFullStacks() && super.isCompletelyFull(enumdirection) : super.isCompletelyFull(enumdirection);
+    }
+
+    @Override
+    public boolean isCompletelyEmpty(Direction enumdirection) {
+        return isNative && this.optimizedItems.isCompletelyEmpty() || super.isCompletelyEmpty(enumdirection);
+    }
+    // Pufferfish end
+
     @Override
     public int getContainerSize() {
         return 27;
@@ -116,7 +139,10 @@ public class ChestBlockEntity extends RandomizableContainerBlockEntity implement
     @Override
     protected void loadAdditional(CompoundTag nbt, HolderLookup.Provider registryLookup) {
         super.loadAdditional(nbt, registryLookup);
-        this.items = NonNullList.withSize(this.getContainerSize(), ItemStack.EMPTY);
+        // Pufferfish start
+        this.optimizedItems = new gg.airplane.structs.ItemListWithBitset(this.getContainerSize());
+        this.items = this.optimizedItems.nonNullList;
+        // Pufferfish end
         if (!this.tryLoadLootTable(nbt)) {
             ContainerHelper.loadAllItems(nbt, this.items, registryLookup);
         }
@@ -188,7 +214,10 @@ public class ChestBlockEntity extends RandomizableContainerBlockEntity implement
 
     @Override
     protected void setItems(NonNullList<ItemStack> inventory) {
-        this.items = inventory;
+        // Pufferfish start
+        this.optimizedItems = gg.airplane.structs.ItemListWithBitset.fromList(inventory);
+        this.items = this.optimizedItems.nonNullList;
+        // Pufferfish end
     }
 
     @Override
diff --git a/src/main/java/net/minecraft/world/level/block/entity/HopperBlockEntity.java b/src/main/java/net/minecraft/world/level/block/entity/HopperBlockEntity.java
index cab403efd471bb61835224eea4e99570d34dcaaa..da3adec177cb28de05b99f7c11897a064f9a557a 100644
--- a/src/main/java/net/minecraft/world/level/block/entity/HopperBlockEntity.java
+++ b/src/main/java/net/minecraft/world/level/block/entity/HopperBlockEntity.java
@@ -48,6 +48,7 @@ public class HopperBlockEntity extends RandomizableContainerBlockEntity implemen
     public static final int HOPPER_CONTAINER_SIZE = 5;
     private static final int[][] CACHED_SLOTS = new int[54][];
     private NonNullList<ItemStack> items;
+    private gg.airplane.structs.ItemListWithBitset optimizedItems; // Pufferfish
     public int cooldownTime;
     private long tickedGameTime;
     private Direction facing;
@@ -84,15 +85,38 @@ public class HopperBlockEntity extends RandomizableContainerBlockEntity implemen
 
     public HopperBlockEntity(BlockPos pos, BlockState state) {
         super(BlockEntityType.HOPPER, pos, state);
-        this.items = NonNullList.withSize(5, ItemStack.EMPTY);
+        // Pufferfish start
+        this.optimizedItems = new gg.airplane.structs.ItemListWithBitset(5);
+        this.items = this.optimizedItems.nonNullList;
+        // Pufferfish end
         this.cooldownTime = -1;
         this.facing = (Direction) state.getValue(HopperBlock.FACING);
     }
 
+    // Pufferfish start
+    @Override
+    public boolean hasEmptySlot(Direction enumdirection) {
+        return !this.optimizedItems.hasFullStacks();
+    }
+
+    @Override
+    public boolean isCompletelyFull(Direction enumdirection) {
+        return this.optimizedItems.hasFullStacks() && super.isCompletelyFull(enumdirection);
+    }
+
+    @Override
+    public boolean isCompletelyEmpty(Direction enumdirection) {
+        return this.optimizedItems.isCompletelyEmpty() || super.isCompletelyEmpty(enumdirection);
+    }
+    // Pufferfish end
+
     @Override
     protected void loadAdditional(CompoundTag nbt, HolderLookup.Provider registryLookup) {
         super.loadAdditional(nbt, registryLookup);
-        this.items = NonNullList.withSize(this.getContainerSize(), ItemStack.EMPTY);
+        // Pufferfish start
+        this.optimizedItems = new gg.airplane.structs.ItemListWithBitset(this.getContainerSize());
+        this.items = this.optimizedItems.nonNullList;
+        // Pufferfish end
         if (!this.tryLoadLootTable(nbt)) {
             ContainerHelper.loadAllItems(nbt, this.items, registryLookup);
         }
@@ -733,7 +757,7 @@ public class HopperBlockEntity extends RandomizableContainerBlockEntity implemen
 
         if (HopperBlockEntity.canPlaceItemInContainer(to, stack, slot, side)) {
             boolean flag = false;
-            boolean flag1 = to.isEmpty();
+            boolean flag1 = to.isCompletelyEmpty(side); // Pufferfish
 
             if (itemstack1.isEmpty()) {
                 // Spigot start - SPIGOT-6693, InventorySubcontainer#setItem
@@ -921,7 +945,10 @@ public class HopperBlockEntity extends RandomizableContainerBlockEntity implemen
 
     @Override
     protected void setItems(NonNullList<ItemStack> inventory) {
-        this.items = inventory;
+        // Pufferfish start
+        this.optimizedItems = gg.airplane.structs.ItemListWithBitset.fromList(inventory);
+        this.items = this.optimizedItems.nonNullList;
+        // Pufferfish end
     }
 
     public static void entityInside(Level world, BlockPos pos, BlockState state, Entity entity, HopperBlockEntity blockEntity) {
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
index 7c11853c5090fbc4fa5b3e73a69acf166158fdec..b28505dc56b1ca6fab4f5112811caa4549c829a1 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunk.java
@@ -86,6 +86,19 @@ public class LevelChunk extends ChunkAccess implements ca.spottedleaf.moonrise.p
     private final LevelChunkTicks<Block> blockTicks;
     private final LevelChunkTicks<Fluid> fluidTicks;
 
+    // Pufferfish start - instead of using a random every time the chunk is ticked, define when lightning strikes preemptively
+    private int lightningTick;
+
+    // shouldDoLightning compiles down to 29 bytes, which with the default of 35 byte inlining should guarantee an inline
+    public final boolean shouldDoLightning(net.minecraft.util.RandomSource random) {
+        if (this.lightningTick-- <= 0) {
+            this.lightningTick = random.nextInt(this.level.spigotConfig.thunderChance) << 1;
+            return true;
+        }
+        return false;
+    }
+    // Pufferfish end
+
     public LevelChunk(Level world, ChunkPos pos) {
         this(world, pos, UpgradeData.EMPTY, new LevelChunkTicks<>(), new LevelChunkTicks<>(), 0L, (LevelChunkSection[]) null, (LevelChunk.PostLoadProcessor) null, (BlendingData) null);
     }
@@ -117,6 +130,8 @@ public class LevelChunk extends ChunkAccess implements ca.spottedleaf.moonrise.p
         this.debug = !empty && this.level.isDebug();
         this.defaultBlockState = empty ? VOID_AIR_BLOCKSTATE : AIR_BLOCKSTATE;
         // Paper end - get block chunk optimisation
+
+        this.lightningTick = this.level.threadUnsafeRandom.nextInt(100000) << 1; // Pufferfish - initialize lightning tick
     }
 
     // CraftBukkit start
diff --git a/src/main/java/net/minecraft/world/level/chunk/LevelChunkSection.java b/src/main/java/net/minecraft/world/level/chunk/LevelChunkSection.java
index c3b1caa352b988ec44fa2b2eb0536517711f5460..ca9879be5180426af72556b9b3ebaaf0cd695716 100644
--- a/src/main/java/net/minecraft/world/level/chunk/LevelChunkSection.java
+++ b/src/main/java/net/minecraft/world/level/chunk/LevelChunkSection.java
@@ -25,6 +25,7 @@ public class LevelChunkSection implements ca.spottedleaf.moonrise.patches.block_
     public final PalettedContainer<BlockState> states;
     // CraftBukkit start - read/write
     private PalettedContainer<Holder<Biome>> biomes;
+    public short fluidStateCount; // Pufferfish
 
     // Paper start - block counting
     private static final it.unimi.dsi.fastutil.ints.IntArrayList FULL_LIST = new it.unimi.dsi.fastutil.ints.IntArrayList(16*16*16);
@@ -104,6 +105,7 @@ public class LevelChunkSection implements ca.spottedleaf.moonrise.patches.block_
 
         if (!fluid.isEmpty()) {
             --this.tickingFluidCount;
+            --this.fluidStateCount; // Pufferfish
         }
 
         if (!state.isAir()) {
@@ -115,6 +117,7 @@ public class LevelChunkSection implements ca.spottedleaf.moonrise.patches.block_
 
         if (!fluid1.isEmpty()) {
             ++this.tickingFluidCount;
+            ++this.fluidStateCount; // Pufferfish
         }
 
         // Paper start - block counting
@@ -208,6 +211,7 @@ public class LevelChunkSection implements ca.spottedleaf.moonrise.patches.block_
                     if (fluid.isRandomlyTicking()) {
                         this.tickingFluidCount += paletteCount;
                     }
+                    LevelChunkSection.this.fluidStateCount++; // Pufferfish
                 }
             }
         }
diff --git a/src/main/java/net/minecraft/world/level/entity/EntityTickList.java b/src/main/java/net/minecraft/world/level/entity/EntityTickList.java
index d8b4196adf955f8d414688dc451caac2d9c609d9..e574f39ce1707e3971e1d54fbd8b6fc6d018654f 100644
--- a/src/main/java/net/minecraft/world/level/entity/EntityTickList.java
+++ b/src/main/java/net/minecraft/world/level/entity/EntityTickList.java
@@ -9,7 +9,7 @@ import javax.annotation.Nullable;
 import net.minecraft.world.entity.Entity;
 
 public class EntityTickList {
-    private final ca.spottedleaf.moonrise.common.list.IteratorSafeOrderedReferenceSet<net.minecraft.world.entity.Entity> entities = new ca.spottedleaf.moonrise.common.list.IteratorSafeOrderedReferenceSet<>(); // Paper - rewrite chunk system
+    public final ca.spottedleaf.moonrise.common.list.IteratorSafeOrderedReferenceSet<net.minecraft.world.entity.Entity> entities = new ca.spottedleaf.moonrise.common.list.IteratorSafeOrderedReferenceSet<>(); // Paper - rewrite chunk system // Pufferfish - private -> public
 
     private void ensureActiveIsNotIterated() {
         // Paper - rewrite chunk system
diff --git a/src/main/java/net/minecraft/world/level/material/FlowingFluid.java b/src/main/java/net/minecraft/world/level/material/FlowingFluid.java
index 1c0712295695727ee9c4d430d4157b8e17cbd71f..fcf2ceffd8268b8bd378b71bf5d301c8e3907446 100644
--- a/src/main/java/net/minecraft/world/level/material/FlowingFluid.java
+++ b/src/main/java/net/minecraft/world/level/material/FlowingFluid.java
@@ -45,14 +45,13 @@ public abstract class FlowingFluid extends Fluid {
     public static final BooleanProperty FALLING = BlockStateProperties.FALLING;
     public static final IntegerProperty LEVEL = BlockStateProperties.LEVEL_FLOWING;
     private static final int CACHE_SIZE = 200;
-    private static final ThreadLocal<Object2ByteLinkedOpenHashMap<Block.BlockStatePairKey>> OCCLUSION_CACHE = ThreadLocal.withInitial(() -> {
-        Object2ByteLinkedOpenHashMap<Block.BlockStatePairKey> object2bytelinkedopenhashmap = new Object2ByteLinkedOpenHashMap<Block.BlockStatePairKey>(200) {
-            protected void rehash(int i) {}
-        };
-
-        object2bytelinkedopenhashmap.defaultReturnValue((byte) 127);
-        return object2bytelinkedopenhashmap;
+    // Pufferfish start - use our own cache
+    private static final ThreadLocal<gg.airplane.structs.FluidDirectionCache<Block.BlockStatePairKey>> localFluidDirectionCache = ThreadLocal.withInitial(() -> {
+        // Pufferfish todo - mess with this number for performance
+        //  with 2048 it seems very infrequent on a small world that it has to remove old entries
+        return new gg.airplane.structs.FluidDirectionCache<>(2048);
     });
+    // Pufferfish end
     private final Map<FluidState, VoxelShape> shapes = Maps.newIdentityHashMap();
 
     public FlowingFluid() {}
@@ -240,22 +239,20 @@ public abstract class FlowingFluid extends Fluid {
     }
 
     private boolean canPassThroughWall(Direction face, BlockGetter world, BlockPos pos, BlockState state, BlockPos fromPos, BlockState fromState) {
-        Object2ByteLinkedOpenHashMap object2bytelinkedopenhashmap;
+        // Pufferfish start - modify to use our cache
+        gg.airplane.structs.FluidDirectionCache<Block.BlockStatePairKey> object2bytelinkedopenhashmap = null;
 
         if (!state.getBlock().hasDynamicShape() && !fromState.getBlock().hasDynamicShape()) {
-            object2bytelinkedopenhashmap = (Object2ByteLinkedOpenHashMap) FlowingFluid.OCCLUSION_CACHE.get();
-        } else {
-            object2bytelinkedopenhashmap = null;
+            object2bytelinkedopenhashmap = localFluidDirectionCache.get();
         }
 
         Block.BlockStatePairKey block_a;
 
         if (object2bytelinkedopenhashmap != null) {
             block_a = new Block.BlockStatePairKey(state, fromState, face);
-            byte b0 = object2bytelinkedopenhashmap.getAndMoveToFirst(block_a);
-
-            if (b0 != 127) {
-                return b0 != 0;
+            Boolean flag = object2bytelinkedopenhashmap.getValue(block_a);
+            if (flag != null) {
+                return flag;
             }
         } else {
             block_a = null;
@@ -266,12 +263,9 @@ public abstract class FlowingFluid extends Fluid {
         boolean flag = !Shapes.mergedFaceOccludes(voxelshape, voxelshape1, face);
 
         if (object2bytelinkedopenhashmap != null) {
-            if (object2bytelinkedopenhashmap.size() == 200) {
-                object2bytelinkedopenhashmap.removeLastByte();
-            }
-
-            object2bytelinkedopenhashmap.putAndMoveToFirst(block_a, (byte) (flag ? 1 : 0));
+            object2bytelinkedopenhashmap.putValue(block_a, flag);
         }
+        // Pufferfish end
 
         return flag;
     }
diff --git a/src/main/java/net/minecraft/world/phys/shapes/EntityCollisionContext.java b/src/main/java/net/minecraft/world/phys/shapes/EntityCollisionContext.java
index 88a4a72bb390947dc17e5da09a99b2d1b3ac4621..47f67ae8b7a88f33c89aa86d8f11f6540287ca1e 100644
--- a/src/main/java/net/minecraft/world/phys/shapes/EntityCollisionContext.java
+++ b/src/main/java/net/minecraft/world/phys/shapes/EntityCollisionContext.java
@@ -17,50 +17,69 @@ public class EntityCollisionContext implements CollisionContext {
             return defaultValue;
         }
     };
-    private final boolean descending;
-    private final double entityBottom;
-    private final ItemStack heldItem;
-    private final Predicate<FluidState> canStandOnFluid;
+    // Pufferfish start - remove these and pray no plugin uses them
+    // private final boolean descending;
+    // private final double entityBottom;
+    // private final ItemStack heldItem;
+    // private final Predicate<FluidState> canStandOnFluid;
+    // Pufferfish end
     @Nullable
     private final Entity entity;
 
     protected EntityCollisionContext(boolean descending, double minY, ItemStack heldItem, Predicate<FluidState> walkOnFluidPredicate, @Nullable Entity entity) {
-        this.descending = descending;
-        this.entityBottom = minY;
-        this.heldItem = heldItem;
-        this.canStandOnFluid = walkOnFluidPredicate;
+        // Pufferfish start - remove these
+        // this.descending = descending;
+        // this.entityBottom = minY;
+        // this.heldItem = heldItem;
+        // this.canStandOnFluid = walkOnFluidPredicate;
+        // Pufferfish end
         this.entity = entity;
     }
 
     @Deprecated
     protected EntityCollisionContext(Entity entity) {
-        this(
-            entity.isDescending(),
-            entity.getY(),
-            entity instanceof LivingEntity ? ((LivingEntity)entity).getMainHandItem() : ItemStack.EMPTY,
-            entity instanceof LivingEntity ? ((LivingEntity)entity)::canStandOnFluid : fluidState -> false,
-            entity
-        );
+        // Pufferfish start - remove this
+        // this(
+        //     entity.isDescending(),
+        //     entity.getY(),
+        //     entity instanceof LivingEntity ? ((LivingEntity)entity).getMainHandItem() : ItemStack.EMPTY,
+        //     entity instanceof LivingEntity ? ((LivingEntity)entity)::canStandOnFluid : fluidState -> false,
+        //     entity
+        // );
+        // Pufferfish end
+        this.entity = entity;
     }
 
     @Override
     public boolean isHoldingItem(Item item) {
-        return this.heldItem.is(item);
+        // Pufferfish start
+        Entity entity = this.entity;
+        if (entity instanceof LivingEntity livingEntity) {
+            return livingEntity.getMainHandItem().is(item);
+        }
+        return ItemStack.EMPTY.is(item);
+        // Pufferfish end
     }
 
     @Override
     public boolean canStandOnFluid(FluidState stateAbove, FluidState state) {
-        return this.canStandOnFluid.test(state) && !stateAbove.getType().isSame(state.getType());
+        // Pufferfish start
+        Entity entity = this.entity;
+        if (entity instanceof LivingEntity livingEntity) {
+            return livingEntity.canStandOnFluid(state) && !stateAbove.getType().isSame(state.getType());
+        }
+        return false;
+        // Pufferfish end
     }
 
     @Override
     public boolean isDescending() {
-        return this.descending;
+        return this.entity != null && this.entity.isDescending(); // Pufferfish
     }
 
     @Override
     public boolean isAbove(VoxelShape shape, BlockPos pos, boolean defaultValue) {
-        return this.entityBottom > (double)pos.getY() + shape.max(Direction.Axis.Y) - 1.0E-5F;
+        return (this.entity == null ? -Double.MAX_VALUE : this.entity.getY()) > (double)pos.getY() + shape.max(Direction.Axis.Y) - 1.0E-5F; // Pufferfish
     }
 
     @Nullable
diff --git a/src/main/java/org/bukkit/craftbukkit/CraftServer.java b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
index b7af2d4300facf41a025c8ca322bf6541949b3ab..87fab3563e2709a38135ae630e820c49d2891d8c 100644
--- a/src/main/java/org/bukkit/craftbukkit/CraftServer.java
+++ b/src/main/java/org/bukkit/craftbukkit/CraftServer.java
@@ -1163,7 +1163,7 @@ public final class CraftServer implements Server {
                 plugin.getPluginMeta().getDisplayName(),
                 "This plugin is not properly shutting down its async tasks when it is being shut down. This task may throw errors during the final shutdown logs and might not complete before process dies."
             ));
-            if (console.isDebugging()) io.papermc.paper.util.TraceUtil.dumpTraceForThread(worker.getThread(), "still running"); // Paper - Debugging
+            if (true || console.isDebugging()) io.papermc.paper.util.TraceUtil.dumpTraceForThread(worker.getThread(), "still running"); // Paper - Debugging // Pufferfish
         }
     }
     // Paper end - Wait for Async Tasks during shutdown
diff --git a/src/main/java/org/bukkit/craftbukkit/util/ServerShutdownThread.java b/src/main/java/org/bukkit/craftbukkit/util/ServerShutdownThread.java
index e8e93538dfd71de86515d9405f728db1631e949a..3dff02fd97f001508e2f81192817bf1b0ef92446 100644
--- a/src/main/java/org/bukkit/craftbukkit/util/ServerShutdownThread.java
+++ b/src/main/java/org/bukkit/craftbukkit/util/ServerShutdownThread.java
@@ -11,6 +11,7 @@ public class ServerShutdownThread extends Thread {
 
     @Override
     public void run() {
+        try { gg.pufferfish.pufferfish.flare.ProfilingManager.stop(); } catch (Throwable t) {} // Pufferfish - shut down Flare if it's running
         try {
             // Paper start - try to shutdown on main
             server.safeShutdown(false, false);
diff --git a/src/main/java/org/spigotmc/ActivationRange.java b/src/main/java/org/spigotmc/ActivationRange.java
index bf2d18f74b0f0da7c3c30310c74224a1c0853564..db825c37219fd5683b7287a8f38e3cc18e78aa57 100644
--- a/src/main/java/org/spigotmc/ActivationRange.java
+++ b/src/main/java/org/spigotmc/ActivationRange.java
@@ -223,6 +223,25 @@ public class ActivationRange
                 }
                 // Paper end - Configurable marker ticking
                 ActivationRange.activateEntity(entity);
+
+                // Pufferfish start
+                if (gg.pufferfish.pufferfish.PufferfishConfig.dearEnabled && entity.getType().dabEnabled) {
+                    if (!entity.activatedPriorityReset) {
+                        entity.activatedPriorityReset = true;
+                        entity.activatedPriority = gg.pufferfish.pufferfish.PufferfishConfig.maximumActivationPrio;
+                    }
+                    net.minecraft.world.phys.Vec3 playerVec = player.position();
+                    net.minecraft.world.phys.Vec3 entityVec = entity.position();
+                    double diffX = playerVec.x - entityVec.x, diffY = playerVec.y - entityVec.y, diffZ = playerVec.z - entityVec.z;
+                    int squaredDistance = (int) (diffX * diffX + diffY * diffY + diffZ * diffZ);
+                    entity.activatedPriority = squaredDistance > gg.pufferfish.pufferfish.PufferfishConfig.startDistanceSquared ?
+                      Math.max(1, Math.min(squaredDistance >> gg.pufferfish.pufferfish.PufferfishConfig.activationDistanceMod, entity.activatedPriority)) :
+                      1;
+                } else {
+                    entity.activatedPriority = 1;
+                }
+                // Pufferfish end
+
             }
             // Paper end
         }
@@ -239,12 +258,12 @@ public class ActivationRange
         if ( MinecraftServer.currentTick > entity.activatedTick )
         {
             if ( entity.defaultActivationState )
-            {
+            { // Pufferfish - diff on change
                 entity.activatedTick = MinecraftServer.currentTick;
                 return;
             }
             if ( entity.activationType.boundingBox.intersects( entity.getBoundingBox() ) )
-            {
+            {  // Pufferfish - diff on change
                 entity.activatedTick = MinecraftServer.currentTick;
             }
         }
@@ -298,7 +317,7 @@ public class ActivationRange
         if ( entity instanceof LivingEntity )
         {
             LivingEntity living = (LivingEntity) entity;
-            if ( living.onClimbable() || living.jumping || living.hurtTime > 0 || living.activeEffects.size() > 0 || living.isFreezing()) // Paper
+            if ( living.onClimableCached() || living.jumping || living.hurtTime > 0 || living.activeEffects.size() > 0 || living.isFreezing()) // Paper // Pufferfish - use cached
             {
                 return 1; // Paper
             }
